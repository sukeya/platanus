<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://sukeya.github.io/platanus/reference/btree_set/" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>btree_set - platanus</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "btree_set";
        var mkdocs_page_input_path = "reference/btree_set.md";
        var mkdocs_page_url = "/platanus/reference/btree_set/";
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> platanus
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Reference</span></p>
              <ul class="current">
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">btree_set</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#template-parameters">Template parameters</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#member-types">Member types</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#member-function">Member function</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#constructor">Constructor</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#iterator">Iterator</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#modifiers">Modifiers</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#insert">insert</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#erase">erase</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#lookup">Lookup</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#capacity">Capacity</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#observers">Observers</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#non-stl">non-STL</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#non-member-function">Non-member function</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#swap">Swap</a>
    </li>
        </ul>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../btree_multiset/">btree_multiset</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../btree_map/">btree_map</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../btree_multimap/">btree_multimap</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">platanus</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">Reference</li>
      <li class="breadcrumb-item active">btree_set</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="btree_set">btree_set</h1>
<p>In <code>platanus/btree_set.h</code>,</p>
<pre><code class="language-cpp">namespace platanus {
template &lt;
    typename Key,
    typename Compare           = std::ranges::less,
    typename Alloc             = std::allocator&lt;Key&gt;,
    std::size_t MaxNumOfValues = 512&gt;
class btree_set;
}
</code></pre>
<h2 id="template-parameters">Template parameters</h2>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Key</code></td>
<td>Type of a key</td>
</tr>
<tr>
<td><code>Compare</code></td>
<td>Type of a func obj comparing two key in a weak order. If Key doesn't implement three-way comparison operator, the default type does using <code>&lt;</code> and <code>=</code>.</td>
</tr>
<tr>
<td><code>Alloc</code></td>
<td>Type of an allocator. The default is <code>std::allocator&lt;Key&gt;</code>.</td>
</tr>
<tr>
<td><code>MaxNumOfValues</code></td>
<td>The max number of values per node. The default is 64.</td>
</tr>
</tbody>
</table>
<h2 id="member-types">Member types</h2>
<table>
<thead>
<tr>
<th>Type</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>key_type</td>
<td>Type of key, i.e. <code>Key</code></td>
</tr>
<tr>
<td>value_type</td>
<td>Type of value, i.e. <code>Key</code></td>
</tr>
<tr>
<td>key_compare</td>
<td>Type of comparer of key, i.e. <code>Compare</code></td>
</tr>
<tr>
<td>value_compare</td>
<td>Type of comparer of value, i.e. <code>Compare</code></td>
</tr>
<tr>
<td>allocator_type</td>
<td>Type of allocator, i.e. <code>Alloc</code></td>
</tr>
<tr>
<td>pointer</td>
<td>Type of pointer to value, i.e. <code>Key*</code></td>
</tr>
<tr>
<td>const_pointer</td>
<td>Type of pointer to const value, i.e. <code>const Key*</code></td>
</tr>
<tr>
<td>reference</td>
<td>Type of reference to value, i.e. <code>Key&amp;</code></td>
</tr>
<tr>
<td>const_reference</td>
<td>Type of reference to const value, i.e. <code>const Key&amp;</code></td>
</tr>
<tr>
<td>size_type</td>
<td>Unsigned integer type of size of <code>btree_set</code>, i.e. <code>std::size_t</code></td>
</tr>
<tr>
<td>difference_type</td>
<td>Signed integer type of the difference of two iterators</td>
</tr>
<tr>
<td>iterator</td>
<td>Type of iterator</td>
</tr>
<tr>
<td>const_iterator</td>
<td>Type of const iterator</td>
</tr>
<tr>
<td>reverse_iterator</td>
<td>Type of reverse iterator</td>
</tr>
<tr>
<td>const_reverse_iterator</td>
<td>Type of const reverse iterator</td>
</tr>
</tbody>
</table>
<h2 id="member-function">Member function</h2>
<h3 id="constructor">Constructor</h3>
<pre><code class="language-cpp">// (1)
btree_set();
// (2)
btree_set(const btree_set&amp;);
// (3)
btree_set(btree_set&amp;&amp;);

// (4)
explicit btree_set(const key_compare&amp; comp, const allocator_type&amp; alloc = allocator_type());
// (5)
explicit btree_set(const allocator_type&amp; alloc);

// (6)
template &lt;class InputIterator&gt;
btree_set(
    InputIterator         b,
    InputIterator         e,
    const key_compare&amp;    comp  = key_compare(),
    const allocator_type&amp; alloc = allocator_type()
);
// (7)
template &lt;class InputIterator&gt;
btree_set(InputIterator b, InputIterator e, const allocator_type&amp; alloc);

// (8)
btree_set(const btree_set&amp; x, const allocator_type&amp; alloc);
// (9)
btree_set(btree_set&amp;&amp; x, const allocator_type&amp; alloc);

// (10)
btree_set(
    std::initializer_list&lt;value_type&gt; init,
    const key_compare&amp;                comp  = key_compare{},
    const allocator_type&amp;             alloc = allocator_type{}
);
// (11)
btree_set(std::initializer_list&lt;value_type&gt; init, const allocator_type&amp; alloc);

// (12)
btree_set&amp; operator=(const btree_set&amp; x);
// (13)
btree_set&amp; operator=(btree_set&amp;&amp;) = default;
</code></pre>
<ol>
<li>Constructs an empty <code>btree_set</code>.</li>
<li>Copy constructor. The allocator is copied by <code>std::allocator_traits::select_on_container_copy_construction</code>.</li>
<li>Move constructor. The allocator is copied by <code>operator=</code>.</li>
<li>Constructs an empty <code>btree_set</code> with <code>comp</code> and <code>alloc</code>.</li>
<li>Constructs an empty <code>btree_set</code> with <code>alloc</code>.</li>
<li>Constructs a <code>btree_set</code> with <code>comp</code> and <code>alloc</code> by inserting values from <code>b</code> to <code>e</code> (<code>e</code> isn't included).</li>
<li>Constructs a <code>btree_set</code> with <code>alloc</code> by inserting values from <code>b</code> to <code>e</code> (<code>e</code> isn't included).</li>
<li>Constructs a copy of <code>x</code> with <code>alloc</code>.</li>
<li>Constructs a <code>btree_set</code> to which <code>x</code> is moved with <code>alloc</code>.</li>
<li>Constructs a <code>btree_set</code> with <code>comp</code> and <code>alloc</code> from an initializer list.</li>
<li>Constructs a <code>btree_set</code> with <code>alloc</code> from an initializer list.</li>
<li>Assigns a copy of <code>x</code> and return <code>*this</code>. If <code>x</code> is <code>*this</code>, does nothing.</li>
<li>Default move assignment operator.</li>
</ol>
<h3 id="iterator">Iterator</h3>
<pre><code class="language-cpp">// (1)
iterator               begin();
// (2)
const_iterator         begin() const;
// (3)
const_iterator         cbegin() const;

// (4)
iterator               end();
// (5)
const_iterator         end() const;
// (6)
const_iterator         cend() const;

// (7)
reverse_iterator       rbegin();
// (8)
const_reverse_iterator rbegin() const;
// (9)
const_reverse_iterator crbegin() const;

// (10)
reverse_iterator       rend();
// (11)
const_reverse_iterator rend() const;
// (12)
const_reverse_iterator crend() const;
</code></pre>
<ol>
<li>Return the iterator pointing to the first value of <code>*this</code>.</li>
<li>The <code>const</code> version of 1.</li>
<li>Return the const iterator pointing to the first value of <code>*this</code>.</li>
<li>Return the iterator pointing to the next address of the last value of <code>*this</code>.</li>
<li>The <code>const</code> version of 4.</li>
<li>Return the const iterator pointing to the next address of the last value of <code>*this</code>.</li>
<li>Return the reverse iterator pointing to the last value of <code>*this</code>.</li>
<li>The <code>const</code> version of 7.</li>
<li>Return the const reverse iterator pointing to the last value of <code>*this</code>.</li>
<li>Return the reverse iterator pointing to the previous address of the first value of <code>*this</code>.</li>
<li>The <code>const</code> version of 10.</li>
<li>Return the const reverse iterator pointing to the previous address of the first value of <code>*this</code>.</li>
</ol>
<h3 id="modifiers">Modifiers</h3>
<pre><code class="language-cpp">// (1)
void clear();
// (2)
void swap(btree_set&amp; x);
// (3)
void merge(btree_set&amp; x);
// (4)
void merge(btree_set&amp;&amp; x);
</code></pre>
<ol>
<li>Clear <code>*this</code>, i.e., delete all values in <code>*this</code>.</li>
<li>Swap <code>*this</code> for <code>x</code>.</li>
<li>Merge another <code>btree_set</code>. The duplicated values will not be merged to <code>*this</code>.</li>
<li>Same as 3. This function is provided to receive an rvalue <code>btree_set</code>, so no rvalue-specific optimization is done.</li>
</ol>
<h4 id="insert"><code>insert</code></h4>
<pre><code class="language-cpp">// (1)
std::pair&lt;iterator, bool&gt; insert(const value_type&amp; x);
// (2)
std::pair&lt;iterator, bool&gt; insert(value_type&amp;&amp; x);

// (3)
iterator insert(iterator hint, const value_type&amp; x);
// (4)
iterator insert(iterator hint, value_type&amp;&amp; x);

// (5)
template &lt;typename InputIterator&gt;
void insert(InputIterator b, InputIterator e);

// (6)
void insert(std::initializer_list&lt;value_type&gt; list);
</code></pre>
<ol>
<li>If there is <code>x</code> in <code>*this</code>, returns an iterator pointing to <code>x</code> in <code>*this</code> and <code>false</code>. Otherwise, inserts <code>x</code> and returns an iterator pointing to <code>x</code> in <code>*this</code> and <code>true</code>.</li>
<li>The rvalue version of 1.</li>
<li>Does 1 with hint. If the value is placed immediately before <code>hint</code> in the tree, the insertion will take amortized constant time. If not, the insertion will take amortized logarithmic time as if a call to <code>insert(x)</code> were made.</li>
<li>The rvalue version of 3.</li>
<li>Does 1 for each value from <code>b</code> to <code>e</code> (<code>e</code> isn't included).</li>
<li>Does 1 for each value of <code>list</code>.</li>
</ol>
<h4 id="erase"><code>erase</code></h4>
<pre><code class="language-cpp">size_type erase(const key_type&amp; key);
iterator  erase(const iterator&amp; iter);
void      erase(const iterator&amp; b, const iterator&amp; e);
</code></pre>
<ol>
<li>Erases the specified key from <code>*this</code> and returns</li>
<li>Erases the specified iterator from <code>*this</code>. The iterator must be valid (i.e. not equal to end()). Return an iterator pointing to the node after the one that was erased (or end() if none exists).</li>
<li>Erases a range from <code>b</code> to <code>e</code> (<code>e</code> isn't included) and return the number of erased keys.</li>
</ol>
<h3 id="lookup">Lookup</h3>
<pre><code class="language-cpp">// (1)
iterator       lower_bound(const key_type&amp; key);
// (2)
const_iterator lower_bound(const key_type&amp; key) const;

// (3)
iterator       upper_bound(const key_type&amp; key);
// (4)
const_iterator upper_bound(const key_type&amp; key) const;

// (5)
std::pair&lt;iterator, iterator&gt; equal_range(const key_type&amp; key);
// (6)
std::pair&lt;const_iterator, const_iterator&gt; equal_range(const key_type&amp; key) const;

// (7)
iterator       find(const key_type&amp; key);
// (8)
const_iterator find(const key_type&amp; key) const;

// (9)
size_type      count(const key_type&amp; key) const;

// (10)
bool           contains(const key_type&amp; key) const;
</code></pre>
<ol>
<li>If <code>*this</code> is empty or <code>key</code> isn't found, returns <code>end()</code>. Otherwise, returns an iterator which points to the minimum value in all values which are not less than <code>key</code>.</li>
<li>The <code>const</code> version of 1.</li>
<li>If <code>*this</code> is empty or <code>key</code> isn't found, returns <code>end()</code>. Otherwise, returns an iterator which points to the minimum value in all values which are greater than <code>key</code>.</li>
<li>The <code>const</code> version of 3.</li>
<li>If <code>*this</code> is empty or <code>key</code> isn't found, returns <code>end()</code>. Otherwise, returns a pair of the iterators which point to the fist value in all values which are equal to <code>key</code> and the value next to the last value in them in order.</li>
<li>The <code>const</code> version of 5.</li>
<li>If <code>*this</code> is empty or <code>key</code> isn't found, returns <code>end()</code>. Otherwise, returns an iterator which points to the fist value in all values which are equal to <code>key</code>.</li>
<li>The <code>const</code> version of 7.</li>
<li>If <code>*this</code> is empty or <code>key</code> isn't found, returns <code>0</code>. Otherwise, returns <code>1</code>.</li>
<li>If <code>*this</code> is empty or <code>key</code> isn't found, returns <code>false</code>. Otherwise, returns <code>true</code>.</li>
</ol>
<h3 id="capacity">Capacity</h3>
<pre><code class="language-cpp">// (1)
size_type size() const;
// (2)
size_type max_size() const;
// (3)
bool      empty() const;
</code></pre>
<ol>
<li>Returns the number of values.</li>
<li>Returns the max number of values.</li>
<li>Returns a bool whether <code>*this</code> is empty or not.</li>
</ol>
<h3 id="observers">Observers</h3>
<pre><code class="language-cpp">key_compare key_comp() const noexcept;
</code></pre>
<p>Returns the <code>key_compare</code> object used by <code>*this</code>.</p>
<h3 id="non-stl">non-STL</h3>
<p><span style="color: red"><strong>[WARNING] The following functions may be suddenly deleted.</strong></span></p>
<pre><code class="language-cpp">// (1)
size_type height() const;
// (2)
size_type internal_nodes() const;
// (3)
size_type leaf_nodes() const;
// (4)
size_type nodes() const;
// (5)
size_type bytes_used() const;
// (6)
double    average_bytes_per_value() const;
// (7)
double    fullness() const;
// (8)
double    overhead() const;
// (9)
void      dump(std::ostream&amp; os) const;
// (10)
void      verify() const;
</code></pre>
<ol>
<li>Returns the hight of <code>*this</code>.</li>
<li>Returns the number of internal nodes.</li>
<li>Returns the number of leaf nodes.</li>
<li>Returns the total of internal nodes and leaf nodes.</li>
<li>Returns the total of bytes used by <code>*this</code>.</li>
<li>Returns the average bytes per value.</li>
<li>Returns the fullness of <code>*this</code>, which is computed as the number of elements in <code>*this</code> divided by the maximum number of elements a tree with the current number of nodes could hold.
A value of 1 indicates perfect space utilization.
Smaller values indicate space wastage.</li>
<li>Returns the overhead of the btree structure in bytes per node, which is computed as the total number of bytes used by <code>*this</code> minus the number of bytes used for storing elements divided by the number of values.</li>
<li>Dumps the btree to the specified ostream. Requires that <code>operator&lt;&lt;</code> is defined for value.</li>
<li>Verifies the structure of <code>*this</code>.</li>
</ol>
<h2 id="non-member-function">Non-member function</h2>
<h3 id="swap">Swap</h3>
<pre><code class="language-cpp">template &lt;typename K, typename C, typename A, std::size_t N&gt;
void swap(btree_set&lt;K, C, A, N&gt;&amp; x, btree_set&lt;K, C, A, N&gt;&amp; y);
</code></pre>
<p>Swap <code>x</code> for <code>y</code> using <code>std::swap</code> to swap each member variable of <code>x</code> for that of <code>y</code>.</p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../.." class="btn btn-neutral float-left" title="Home"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../btree_multiset/" class="btn btn-neutral float-right" title="btree_multiset">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../.." style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../btree_multiset/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
