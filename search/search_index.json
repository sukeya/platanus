{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"platanus platanus is an fork of the B-tree library cpp-btree . Comparing to STL set/map A btree is both smaller and faster than STL set/map. The red-black tree implementation of STL set/map has an overhead of 3 pointers (left, right and parent) plus the node color information for each stored value. So a std::set<std::int32_t> consumes 32 bytes for each value stored. This btree implementation stores the fixed number of values on a nodes (usually 64) and doesn't store child pointers for leaf nodes. The result is that a platanus::btree_set<std::int32> may use much less memory per stored value. For the random insertion benchmark in btree_test.cc, a platanus::btree_set<std::int32_t> with 64 values per node uses 4.64 bytes per stored value. The packing of multiple values on to each node of a btree has another effect besides better space utilization: better cache locality due to fewer cache lines being accessed. Better cache locality translates into faster operations. Feature satisfying alignment requirement, supporting stateful comparer, the standard C++ container-like interface, supporting CMake, easier to read than the original, supporting three-way comparison operator. Performance Generally speaking, platunus is slower than cpp-btree by approximately 13%, but is faster than std::(multi)set and std::(multi)map by approximately 59% (the values are median and the order of B-tree is 65 (default)). However, forwarding an iterator of platanus is extremely faster than doing that of STL, while FIFO of platanus is slower than that of STL by approximately 19%. So, you should check how much the performance is improved. Limitation and caveats Supporting the orders of B-Tree We need at least 3 values per a node in order to perform splitting (1 value for the two nodes involved in the split and 1 value propagated to the parent as the delimiter for the split). That is, We don't support the 3 order B-trees. Invalidating iterators after insertions and deletions Insertions and deletions on a btree can cause splitting, merging or rebalancing of btree nodes. And even without these operations, insertions and deletions on a btree will move values around within a node. In both cases, the result is that insertions and deletions can invalidate iterators pointing to values other than the one being inserted/deleted. This is notably different from STL set/map which takes care to not invalidate iterators on insert / erase except, of course, for iterators pointing to the value being erased. A partial workaround when erasing is available: erase() returns an iterator pointing to the item just after the one that was erased (or end() if none exists). Installation platanus is an header only library, so you don't have to install it. When using CMake, you only have to link your program to platanus . For example, target_link_libraries(your_program PUBLIC platanus) . Test If you want to test, download and install the following libraries. googletest benchmark Then, run the following commands in the top directory of platanus . cmake -S . -B build/debug -DBUILD_TESTS=ON -DCMAKE_BUILD_TYPE=Debug cd build/debug/test ./btree_test Performance test If you want to check how much platanus is faster than STL, run the following commands. cmake -S . -B build/release -DBUILD_TESTS=ON -DCMAKE_BUILD_TYPE=Release cd build/release/benchmark ./btree_bench The output has the following form. BM_<(\"STL\" or \"BTree\")(container type)<(value type)[, (the max number of values per node)]>> (average time[ns] per iteration) (average CPU time[ns] per iteration) (the total of iterations) The test cases are: test case meaning Insert Benchmark insertion of random values into an empty container. Lookup Benchmark lookup of random values in a container. Delete Benchmark deletion of random values from a container. FwdIter Benchmark iteration (forward) through the container. Merge Benchmark merging two containers with the same size. If you want to know a good size of values per node, run the following comamnd. cmake -S . -B build/release -DBUILD_TESTS=ON -DCMAKE_BUILD_TYPE=Release -DVALUES_SIZE_TEST cd build/release/benchmark ./btree_bench The result on my environment is here . License platanus is licensed under Apache License, Version 2.0 .","title":"Home"},{"location":"#platanus","text":"platanus is an fork of the B-tree library cpp-btree .","title":"platanus"},{"location":"#comparing-to-stl-setmap","text":"A btree is both smaller and faster than STL set/map. The red-black tree implementation of STL set/map has an overhead of 3 pointers (left, right and parent) plus the node color information for each stored value. So a std::set<std::int32_t> consumes 32 bytes for each value stored. This btree implementation stores the fixed number of values on a nodes (usually 64) and doesn't store child pointers for leaf nodes. The result is that a platanus::btree_set<std::int32> may use much less memory per stored value. For the random insertion benchmark in btree_test.cc, a platanus::btree_set<std::int32_t> with 64 values per node uses 4.64 bytes per stored value. The packing of multiple values on to each node of a btree has another effect besides better space utilization: better cache locality due to fewer cache lines being accessed. Better cache locality translates into faster operations.","title":"Comparing to STL set/map"},{"location":"#feature","text":"satisfying alignment requirement, supporting stateful comparer, the standard C++ container-like interface, supporting CMake, easier to read than the original, supporting three-way comparison operator.","title":"Feature"},{"location":"#performance","text":"Generally speaking, platunus is slower than cpp-btree by approximately 13%, but is faster than std::(multi)set and std::(multi)map by approximately 59% (the values are median and the order of B-tree is 65 (default)). However, forwarding an iterator of platanus is extremely faster than doing that of STL, while FIFO of platanus is slower than that of STL by approximately 19%. So, you should check how much the performance is improved.","title":"Performance"},{"location":"#limitation-and-caveats","text":"","title":"Limitation and caveats"},{"location":"#supporting-the-orders-of-b-tree","text":"We need at least 3 values per a node in order to perform splitting (1 value for the two nodes involved in the split and 1 value propagated to the parent as the delimiter for the split). That is, We don't support the 3 order B-trees.","title":"Supporting the orders of B-Tree"},{"location":"#invalidating-iterators-after-insertions-and-deletions","text":"Insertions and deletions on a btree can cause splitting, merging or rebalancing of btree nodes. And even without these operations, insertions and deletions on a btree will move values around within a node. In both cases, the result is that insertions and deletions can invalidate iterators pointing to values other than the one being inserted/deleted. This is notably different from STL set/map which takes care to not invalidate iterators on insert / erase except, of course, for iterators pointing to the value being erased. A partial workaround when erasing is available: erase() returns an iterator pointing to the item just after the one that was erased (or end() if none exists).","title":"Invalidating iterators after insertions and deletions"},{"location":"#installation","text":"platanus is an header only library, so you don't have to install it. When using CMake, you only have to link your program to platanus . For example, target_link_libraries(your_program PUBLIC platanus) .","title":"Installation"},{"location":"#test","text":"If you want to test, download and install the following libraries. googletest benchmark Then, run the following commands in the top directory of platanus . cmake -S . -B build/debug -DBUILD_TESTS=ON -DCMAKE_BUILD_TYPE=Debug cd build/debug/test ./btree_test","title":"Test"},{"location":"#performance-test","text":"If you want to check how much platanus is faster than STL, run the following commands. cmake -S . -B build/release -DBUILD_TESTS=ON -DCMAKE_BUILD_TYPE=Release cd build/release/benchmark ./btree_bench The output has the following form. BM_<(\"STL\" or \"BTree\")(container type)<(value type)[, (the max number of values per node)]>> (average time[ns] per iteration) (average CPU time[ns] per iteration) (the total of iterations) The test cases are: test case meaning Insert Benchmark insertion of random values into an empty container. Lookup Benchmark lookup of random values in a container. Delete Benchmark deletion of random values from a container. FwdIter Benchmark iteration (forward) through the container. Merge Benchmark merging two containers with the same size. If you want to know a good size of values per node, run the following comamnd. cmake -S . -B build/release -DBUILD_TESTS=ON -DCMAKE_BUILD_TYPE=Release -DVALUES_SIZE_TEST cd build/release/benchmark ./btree_bench The result on my environment is here .","title":"Performance test"},{"location":"#license","text":"platanus is licensed under Apache License, Version 2.0 .","title":"License"},{"location":"reference/btree_map/","text":"btree_map In platanus/btree_map.h , namespace platanus { template < typename Key, typename Value, typename Compare = std::ranges::less, typename Alloc = std::allocator<Key>, std::size_t MaxNumOfValues = 512> class btree_map; } Template parameters Parameter Meaning Key Type of a key Value Type of a value Compare Type of a func obj comparing two key in a weak order. If Key doesn't implement three-way comparison operator, the default type does using < and = . Alloc Type of an allocator. The default is std::allocator<Key> . MaxNumOfValues The max number of values per node. The default is 64. Member types Type Meaning key_type Type of key, i.e. Key value_type Type of value, i.e. std::pair<const Key, Value> mapped_type Type of mapped value, i.e. Value key_compare Type of comparer of key, i.e. Compare allocator_type Type of allocator, i.e. Alloc pointer Type of pointer to value, i.e. value_type* const_pointer Type of pointer to const value, i.e. const value_type* reference Type of reference to value, i.e. value_type& const_reference Type of reference to const value, i.e. const value_type& size_type Unsigned integer type of size of btree_map , i.e. std::size_t difference_type Signed integer type of the difference of two iterators iterator Type of iterator const_iterator Type of const iterator reverse_iterator Type of reverse iterator const_reverse_iterator Type of const reverse iterator Member function Constructor // (1) btree_map(); // (2) btree_map(const btree_map&); // (3) btree_map(btree_map&&); // (4) explicit btree_map(const key_compare& comp, const allocator_type& alloc = allocator_type()); // (5) explicit btree_map(const allocator_type& alloc); // (6) template <class InputIterator> btree_map( InputIterator b, InputIterator e, const key_compare& comp = key_compare(), const allocator_type& alloc = allocator_type() ); // (7) template <class InputIterator> btree_map(InputIterator b, InputIterator e, const allocator_type& alloc); // (8) btree_map(const btree_map& x, const allocator_type& alloc); // (9) btree_map(btree_map&& x, const allocator_type& alloc); // (10) btree_map( std::initializer_list<value_type> init, const key_compare& comp = key_compare{}, const allocator_type& alloc = allocator_type{} ); // (11) btree_map(std::initializer_list<value_type> init, const allocator_type& alloc); // (12) btree_map& operator=(const btree_map& x); // (13) btree_map& operator=(btree_map&&) = default; Constructs an empty btree_map . Copy constructor. The allocator is copied by std::allocator_traits::select_on_container_copy_construction . Move constructor. The allocator is copied by operator= . Constructs an empty btree_map with comp and alloc . Constructs an empty btree_map with alloc . Constructs a btree_map with comp and alloc by inserting values from b to e ( e isn't included). Constructs a btree_map with alloc by inserting values from b to e ( e isn't included). Constructs a copy of x with alloc . Constructs a btree_map to which x is moved with alloc . Constructs a btree_map with comp and alloc from an initializer list. Constructs a btree_map with alloc from an initializer list. Assigns a copy of x and return *this . If x is *this , does nothing. Default move assignment operator. Iterator // (1) iterator begin(); // (2) const_iterator begin() const; // (3) const_iterator cbegin() const; // (4) iterator end(); // (5) const_iterator end() const; // (6) const_iterator cend() const; // (7) reverse_iterator rbegin(); // (8) const_reverse_iterator rbegin() const; // (9) const_reverse_iterator crbegin() const; // (10) reverse_iterator rend(); // (11) const_reverse_iterator rend() const; // (12) const_reverse_iterator crend() const; Return the iterator pointing to the first value of *this . The const version of 1. Return the const iterator pointing to the first value of *this . Return the iterator pointing to the next address of the last value of *this . The const version of 4. Return the const iterator pointing to the next address of the last value of *this . Return the reverse iterator pointing to the last value of *this . The const version of 7. Return the const reverse iterator pointing to the last value of *this . Return the reverse iterator pointing to the previous address of the first value of *this . The const version of 10. Return the const reverse iterator pointing to the previous address of the first value of *this . Modifiers // (1) void clear(); // (2) void swap(btree_map& x); // (3) void merge(btree_map& x); // (4) void merge(btree_map&& x); // (5) mapped_type& operator[](const key_type& key); // (6) mapped_type& operator[](key_type&& key); Clear *this , i.e., delete all values in *this . Swap *this for x . Merge another btree_map . The duplicated values will not be merged to *this . Same as 3. This function is provided to receive an rvalue btree_map , so no rvalue-specific optimization is done. Return the reference of the value mapped to key . If key doesn't exist, insert key and default constructed mapped_value . The rvalue version of 5. insert // (1) std::pair<iterator, bool> insert(const value_type& x); // (2) std::pair<iterator, bool> insert(value_type&& x); // (3) iterator insert(iterator hint, const value_type& x); // (4) iterator insert(iterator hint, value_type&& x); // (5) template <typename InputIterator> void insert(InputIterator b, InputIterator e); // (6) void insert(std::initializer_list<value_type> list); If there is x in *this , returns an iterator pointing to x in *this and false . Otherwise, inserts x and returns an iterator pointing to x in *this and true . The rvalue version of 1. Does 1 with hint. If the value is placed immediately before hint in the tree, the insertion will take amortized constant time. If not, the insertion will take amortized logarithmic time as if a call to insert(x) were made. The rvalue version of 3. Does 1 for each value from b to e ( e isn't included). Does 1 for each value of list . erase size_type erase(const key_type& key); iterator erase(const iterator& iter); void erase(const iterator& b, const iterator& e); Erases the specified key from *this and returns Erases the specified iterator from *this . The iterator must be valid (i.e. not equal to end()). Return an iterator pointing to the node after the one that was erased (or end() if none exists). Erases a range from b to e ( e isn't included) and return the number of erased keys. Lookup // (1) iterator lower_bound(const key_type& key); // (2) const_iterator lower_bound(const key_type& key) const; // (3) iterator upper_bound(const key_type& key); // (4) const_iterator upper_bound(const key_type& key) const; // (5) std::pair<iterator, iterator> equal_range(const key_type& key); // (6) std::pair<const_iterator, const_iterator> equal_range(const key_type& key) const; // (7) iterator find(const key_type& key); // (8) const_iterator find(const key_type& key) const; // (9) size_type count(const key_type& key) const; // (10) bool contains(const key_type& key) const; If *this is empty or key isn't found, returns end() . Otherwise, returns an iterator which points to the minimum value in all values which are not less than key . The const version of 1. If *this is empty or key isn't found, returns end() . Otherwise, returns an iterator which points to the minimum value in all values which are greater than key . The const version of 3. If *this is empty or key isn't found, returns std::make_pair(end(), end()) . Otherwise, returns a pair of the iterators which point to the fist value in all values which are equal to key and the value next to the last value in them in order. The const version of 5. If *this is empty or key isn't found, returns end() . Otherwise, returns an iterator which points to the fist value in all values which are equal to key . The const version of 7. If *this is empty or key isn't found, returns 0 . Otherwise, returns 1 . If *this is empty or key isn't found, returns false . Otherwise, returns true . Capacity // (1) size_type size() const; // (2) size_type max_size() const; // (3) bool empty() const; Returns the number of values. Returns the max number of values. Returns a bool whether *this is empty or not. Observers key_compare key_comp() const noexcept; Returns the key_compare object used by *this . non-STL [WARNING] The following functions may be suddenly deleted. // (1) size_type height() const; // (2) size_type internal_nodes() const; // (3) size_type leaf_nodes() const; // (4) size_type nodes() const; // (5) size_type bytes_used() const; // (6) double average_bytes_per_value() const; // (7) double fullness() const; // (8) double overhead() const; // (9) void dump(std::ostream& os) const; // (10) void verify() const; Returns the hight of *this . Returns the number of internal nodes. Returns the number of leaf nodes. Returns the total of internal nodes and leaf nodes. Returns the total of bytes used by *this . Returns the average bytes per value. Returns the fullness of *this , which is computed as the number of elements in *this divided by the maximum number of elements a tree with the current number of nodes could hold. A value of 1 indicates perfect space utilization. Smaller values indicate space wastage. Returns the overhead of the btree structure in bytes per node, which is computed as the total number of bytes used by *this minus the number of bytes used for storing elements divided by the number of values. Dumps the btree to the specified ostream. Requires that operator<< is defined for value. Verifies the structure of *this . Non-member function Swap template <typename K, typename C, typename A, std::size_t N> void swap(btree_map<K, C, A, N>& x, btree_map<K, C, A, N>& y); Swap x for y using std::swap to swap each member variable of x for that of y .","title":"btree_map"},{"location":"reference/btree_map/#btree_map","text":"In platanus/btree_map.h , namespace platanus { template < typename Key, typename Value, typename Compare = std::ranges::less, typename Alloc = std::allocator<Key>, std::size_t MaxNumOfValues = 512> class btree_map; }","title":"btree_map"},{"location":"reference/btree_map/#template-parameters","text":"Parameter Meaning Key Type of a key Value Type of a value Compare Type of a func obj comparing two key in a weak order. If Key doesn't implement three-way comparison operator, the default type does using < and = . Alloc Type of an allocator. The default is std::allocator<Key> . MaxNumOfValues The max number of values per node. The default is 64.","title":"Template parameters"},{"location":"reference/btree_map/#member-types","text":"Type Meaning key_type Type of key, i.e. Key value_type Type of value, i.e. std::pair<const Key, Value> mapped_type Type of mapped value, i.e. Value key_compare Type of comparer of key, i.e. Compare allocator_type Type of allocator, i.e. Alloc pointer Type of pointer to value, i.e. value_type* const_pointer Type of pointer to const value, i.e. const value_type* reference Type of reference to value, i.e. value_type& const_reference Type of reference to const value, i.e. const value_type& size_type Unsigned integer type of size of btree_map , i.e. std::size_t difference_type Signed integer type of the difference of two iterators iterator Type of iterator const_iterator Type of const iterator reverse_iterator Type of reverse iterator const_reverse_iterator Type of const reverse iterator","title":"Member types"},{"location":"reference/btree_map/#member-function","text":"","title":"Member function"},{"location":"reference/btree_map/#constructor","text":"// (1) btree_map(); // (2) btree_map(const btree_map&); // (3) btree_map(btree_map&&); // (4) explicit btree_map(const key_compare& comp, const allocator_type& alloc = allocator_type()); // (5) explicit btree_map(const allocator_type& alloc); // (6) template <class InputIterator> btree_map( InputIterator b, InputIterator e, const key_compare& comp = key_compare(), const allocator_type& alloc = allocator_type() ); // (7) template <class InputIterator> btree_map(InputIterator b, InputIterator e, const allocator_type& alloc); // (8) btree_map(const btree_map& x, const allocator_type& alloc); // (9) btree_map(btree_map&& x, const allocator_type& alloc); // (10) btree_map( std::initializer_list<value_type> init, const key_compare& comp = key_compare{}, const allocator_type& alloc = allocator_type{} ); // (11) btree_map(std::initializer_list<value_type> init, const allocator_type& alloc); // (12) btree_map& operator=(const btree_map& x); // (13) btree_map& operator=(btree_map&&) = default; Constructs an empty btree_map . Copy constructor. The allocator is copied by std::allocator_traits::select_on_container_copy_construction . Move constructor. The allocator is copied by operator= . Constructs an empty btree_map with comp and alloc . Constructs an empty btree_map with alloc . Constructs a btree_map with comp and alloc by inserting values from b to e ( e isn't included). Constructs a btree_map with alloc by inserting values from b to e ( e isn't included). Constructs a copy of x with alloc . Constructs a btree_map to which x is moved with alloc . Constructs a btree_map with comp and alloc from an initializer list. Constructs a btree_map with alloc from an initializer list. Assigns a copy of x and return *this . If x is *this , does nothing. Default move assignment operator.","title":"Constructor"},{"location":"reference/btree_map/#iterator","text":"// (1) iterator begin(); // (2) const_iterator begin() const; // (3) const_iterator cbegin() const; // (4) iterator end(); // (5) const_iterator end() const; // (6) const_iterator cend() const; // (7) reverse_iterator rbegin(); // (8) const_reverse_iterator rbegin() const; // (9) const_reverse_iterator crbegin() const; // (10) reverse_iterator rend(); // (11) const_reverse_iterator rend() const; // (12) const_reverse_iterator crend() const; Return the iterator pointing to the first value of *this . The const version of 1. Return the const iterator pointing to the first value of *this . Return the iterator pointing to the next address of the last value of *this . The const version of 4. Return the const iterator pointing to the next address of the last value of *this . Return the reverse iterator pointing to the last value of *this . The const version of 7. Return the const reverse iterator pointing to the last value of *this . Return the reverse iterator pointing to the previous address of the first value of *this . The const version of 10. Return the const reverse iterator pointing to the previous address of the first value of *this .","title":"Iterator"},{"location":"reference/btree_map/#modifiers","text":"// (1) void clear(); // (2) void swap(btree_map& x); // (3) void merge(btree_map& x); // (4) void merge(btree_map&& x); // (5) mapped_type& operator[](const key_type& key); // (6) mapped_type& operator[](key_type&& key); Clear *this , i.e., delete all values in *this . Swap *this for x . Merge another btree_map . The duplicated values will not be merged to *this . Same as 3. This function is provided to receive an rvalue btree_map , so no rvalue-specific optimization is done. Return the reference of the value mapped to key . If key doesn't exist, insert key and default constructed mapped_value . The rvalue version of 5.","title":"Modifiers"},{"location":"reference/btree_map/#insert","text":"// (1) std::pair<iterator, bool> insert(const value_type& x); // (2) std::pair<iterator, bool> insert(value_type&& x); // (3) iterator insert(iterator hint, const value_type& x); // (4) iterator insert(iterator hint, value_type&& x); // (5) template <typename InputIterator> void insert(InputIterator b, InputIterator e); // (6) void insert(std::initializer_list<value_type> list); If there is x in *this , returns an iterator pointing to x in *this and false . Otherwise, inserts x and returns an iterator pointing to x in *this and true . The rvalue version of 1. Does 1 with hint. If the value is placed immediately before hint in the tree, the insertion will take amortized constant time. If not, the insertion will take amortized logarithmic time as if a call to insert(x) were made. The rvalue version of 3. Does 1 for each value from b to e ( e isn't included). Does 1 for each value of list .","title":"insert"},{"location":"reference/btree_map/#erase","text":"size_type erase(const key_type& key); iterator erase(const iterator& iter); void erase(const iterator& b, const iterator& e); Erases the specified key from *this and returns Erases the specified iterator from *this . The iterator must be valid (i.e. not equal to end()). Return an iterator pointing to the node after the one that was erased (or end() if none exists). Erases a range from b to e ( e isn't included) and return the number of erased keys.","title":"erase"},{"location":"reference/btree_map/#lookup","text":"// (1) iterator lower_bound(const key_type& key); // (2) const_iterator lower_bound(const key_type& key) const; // (3) iterator upper_bound(const key_type& key); // (4) const_iterator upper_bound(const key_type& key) const; // (5) std::pair<iterator, iterator> equal_range(const key_type& key); // (6) std::pair<const_iterator, const_iterator> equal_range(const key_type& key) const; // (7) iterator find(const key_type& key); // (8) const_iterator find(const key_type& key) const; // (9) size_type count(const key_type& key) const; // (10) bool contains(const key_type& key) const; If *this is empty or key isn't found, returns end() . Otherwise, returns an iterator which points to the minimum value in all values which are not less than key . The const version of 1. If *this is empty or key isn't found, returns end() . Otherwise, returns an iterator which points to the minimum value in all values which are greater than key . The const version of 3. If *this is empty or key isn't found, returns std::make_pair(end(), end()) . Otherwise, returns a pair of the iterators which point to the fist value in all values which are equal to key and the value next to the last value in them in order. The const version of 5. If *this is empty or key isn't found, returns end() . Otherwise, returns an iterator which points to the fist value in all values which are equal to key . The const version of 7. If *this is empty or key isn't found, returns 0 . Otherwise, returns 1 . If *this is empty or key isn't found, returns false . Otherwise, returns true .","title":"Lookup"},{"location":"reference/btree_map/#capacity","text":"// (1) size_type size() const; // (2) size_type max_size() const; // (3) bool empty() const; Returns the number of values. Returns the max number of values. Returns a bool whether *this is empty or not.","title":"Capacity"},{"location":"reference/btree_map/#observers","text":"key_compare key_comp() const noexcept; Returns the key_compare object used by *this .","title":"Observers"},{"location":"reference/btree_map/#non-stl","text":"[WARNING] The following functions may be suddenly deleted. // (1) size_type height() const; // (2) size_type internal_nodes() const; // (3) size_type leaf_nodes() const; // (4) size_type nodes() const; // (5) size_type bytes_used() const; // (6) double average_bytes_per_value() const; // (7) double fullness() const; // (8) double overhead() const; // (9) void dump(std::ostream& os) const; // (10) void verify() const; Returns the hight of *this . Returns the number of internal nodes. Returns the number of leaf nodes. Returns the total of internal nodes and leaf nodes. Returns the total of bytes used by *this . Returns the average bytes per value. Returns the fullness of *this , which is computed as the number of elements in *this divided by the maximum number of elements a tree with the current number of nodes could hold. A value of 1 indicates perfect space utilization. Smaller values indicate space wastage. Returns the overhead of the btree structure in bytes per node, which is computed as the total number of bytes used by *this minus the number of bytes used for storing elements divided by the number of values. Dumps the btree to the specified ostream. Requires that operator<< is defined for value. Verifies the structure of *this .","title":"non-STL"},{"location":"reference/btree_map/#non-member-function","text":"","title":"Non-member function"},{"location":"reference/btree_map/#swap","text":"template <typename K, typename C, typename A, std::size_t N> void swap(btree_map<K, C, A, N>& x, btree_map<K, C, A, N>& y); Swap x for y using std::swap to swap each member variable of x for that of y .","title":"Swap"},{"location":"reference/btree_multimap/","text":"btree_multimap In platanus/btree_map.h , namespace platanus { template < typename Key, typename Value, typename Compare = std::ranges::less, typename Alloc = std::allocator<Key>, std::size_t MaxNumOfValues = 512> class btree_multimap; } Template parameters Parameter Meaning Key Type of a key Value Type of a value Compare Type of a func obj comparing two key in a weak order. If Key doesn't implement three-way comparison operator, the default type does using < and = . Alloc Type of an allocator. The default is std::allocator<Key> . MaxNumOfValues The max number of values per node. The default is 64. Member types Type Meaning key_type Type of key, i.e. Key value_type Type of value, i.e. std::pair<const Key, Value> mapped_type Type of mapped value, i.e. Value key_compare Type of comparer of key, i.e. Compare allocator_type Type of allocator, i.e. Alloc pointer Type of pointer to value, i.e. value_type* const_pointer Type of pointer to const value, i.e. const value_type* reference Type of reference to value, i.e. value_type& const_reference Type of reference to const value, i.e. const value_type& size_type Unsigned integer type of size of btree_multimap , i.e. std::size_t difference_type Signed integer type of the difference of two iterators iterator Type of iterator const_iterator Type of const iterator reverse_iterator Type of reverse iterator const_reverse_iterator Type of const reverse iterator Member function Constructor // (1) btree_multimap(); // (2) btree_multimap(const btree_multimap&); // (3) btree_multimap(btree_multimap&&); // (4) explicit btree_multimap(const key_compare& comp, const allocator_type& alloc = allocator_type()); // (5) explicit btree_multimap(const allocator_type& alloc); // (6) template <class InputIterator> btree_multimap( InputIterator b, InputIterator e, const key_compare& comp = key_compare(), const allocator_type& alloc = allocator_type() ); // (7) template <class InputIterator> btree_multimap(InputIterator b, InputIterator e, const allocator_type& alloc); // (8) btree_multimap(const btree_multimap& x, const allocator_type& alloc); // (9) btree_multimap(btree_multimap&& x, const allocator_type& alloc); // (10) btree_multimap( std::initializer_list<value_type> init, const key_compare& comp = key_compare{}, const allocator_type& alloc = allocator_type{} ); // (11) btree_multimap(std::initializer_list<value_type> init, const allocator_type& alloc); // (12) btree_multimap& operator=(const btree_multimap& x); // (13) btree_multimap& operator=(btree_multimap&&) = default; Constructs an empty btree_multimap . Copy constructor. The allocator is copied by std::allocator_traits::select_on_container_copy_construction . Move constructor. The allocator is copied by operator= . Constructs an empty btree_multimap with comp and alloc . Constructs an empty btree_multimap with alloc . Constructs a btree_multimap with comp and alloc by inserting values from b to e ( e isn't included). Constructs a btree_multimap with alloc by inserting values from b to e ( e isn't included). Constructs a copy of x with alloc . Constructs a btree_multimap to which x is moved with alloc . Constructs a btree_multimap with comp and alloc from an initializer list. Constructs a btree_multimap with alloc from an initializer list. Assigns a copy of x and return *this . If x is *this , does nothing. Default move assignment operator. Iterator // (1) iterator begin(); // (2) const_iterator begin() const; // (3) const_iterator cbegin() const; // (4) iterator end(); // (5) const_iterator end() const; // (6) const_iterator cend() const; // (7) reverse_iterator rbegin(); // (8) const_reverse_iterator rbegin() const; // (9) const_reverse_iterator crbegin() const; // (10) reverse_iterator rend(); // (11) const_reverse_iterator rend() const; // (12) const_reverse_iterator crend() const; Return the iterator pointing to the first value of *this . The const version of 1. Return the const iterator pointing to the first value of *this . Return the iterator pointing to the next address of the last value of *this . The const version of 4. Return the const iterator pointing to the next address of the last value of *this . Return the reverse iterator pointing to the last value of *this . The const version of 7. Return the const reverse iterator pointing to the last value of *this . Return the reverse iterator pointing to the previous address of the first value of *this . The const version of 10. Return the const reverse iterator pointing to the previous address of the first value of *this . Modifiers // (1) void clear(); // (2) void swap(btree_multimap& x); // (3) void merge(btree_multimap& x); // (4) void merge(btree_multimap&& x); Clear *this , i.e., delete all values in *this . Swap *this for x . Merge another btree_multimap . The duplicated values will not be merged to *this . Same as 3. This function is provided to receive an rvalue btree_multimap , so no rvalue-specific optimization is done. insert // (1) std::pair<iterator, bool> insert(const value_type& x); // (2) std::pair<iterator, bool> insert(value_type&& x); // (3) iterator insert(iterator hint, const value_type& x); // (4) iterator insert(iterator hint, value_type&& x); // (5) template <typename InputIterator> void insert(InputIterator b, InputIterator e); // (6) void insert(std::initializer_list<value_type> list); If there is x in *this , returns an iterator pointing to x in *this and false . Otherwise, inserts x and returns an iterator pointing to x in *this and true . The rvalue version of 1. Does 1 with hint. If the value is placed immediately before hint in the tree, the insertion will take amortized constant time. If not, the insertion will take amortized logarithmic time as if a call to insert(x) were made. The rvalue version of 3. Does 1 for each value from b to e ( e isn't included). Does 1 for each value of list . erase size_type erase(const key_type& key); iterator erase(const iterator& iter); void erase(const iterator& b, const iterator& e); Erases the specified key from *this and returns Erases the specified iterator from *this . The iterator must be valid (i.e. not equal to end()). Return an iterator pointing to the node after the one that was erased (or end() if none exists). Erases a range from b to e ( e isn't included) and return the number of erased keys. Lookup // (1) iterator lower_bound(const key_type& key); // (2) const_iterator lower_bound(const key_type& key) const; // (3) iterator upper_bound(const key_type& key); // (4) const_iterator upper_bound(const key_type& key) const; // (5) std::pair<iterator, iterator> equal_range(const key_type& key); // (6) std::pair<const_iterator, const_iterator> equal_range(const key_type& key) const; // (7) iterator find(const key_type& key); // (8) const_iterator find(const key_type& key) const; // (9) size_type count(const key_type& key) const; // (10) bool contains(const key_type& key) const; If *this is empty or key isn't found, returns end() . Otherwise, returns an iterator which points to the minimum value in all values which are not less than key . The const version of 1. If *this is empty or key isn't found, returns end() . Otherwise, returns an iterator which points to the minimum value in all values which are greater than key . The const version of 3. If *this is empty or key isn't found, returns end() . Otherwise, returns a pair of the iterators which point to the fist value in all values which are equal to key and the value next to the last value in them in order. The const version of 5. If *this is empty or key isn't found, returns end() . Otherwise, returns an iterator which points to the fist value in all values which are equal to key . The const version of 7. If *this is empty or key isn't found, returns 0 . Otherwise, returns 1 . If *this is empty or key isn't found, returns false . Otherwise, returns true . Capacity // (1) size_type size() const; // (2) size_type max_size() const; // (3) bool empty() const; Returns the number of values. Returns the max number of values. Returns a bool whether *this is empty or not. Observers key_compare key_comp() const noexcept; Returns the key_compare object used by *this . non-STL [WARNING] The following functions may be suddenly deleted. // (1) size_type height() const; // (2) size_type internal_nodes() const; // (3) size_type leaf_nodes() const; // (4) size_type nodes() const; // (5) size_type bytes_used() const; // (6) double average_bytes_per_value() const; // (7) double fullness() const; // (8) double overhead() const; // (9) void dump(std::ostream& os) const; // (10) void verify() const; Returns the hight of *this . Returns the number of internal nodes. Returns the number of leaf nodes. Returns the total of internal nodes and leaf nodes. Returns the total of bytes used by *this . Returns the average bytes per value. Returns the fullness of *this , which is computed as the number of elements in *this divided by the maximum number of elements a tree with the current number of nodes could hold. A value of 1 indicates perfect space utilization. Smaller values indicate space wastage. Returns the overhead of the btree structure in bytes per node, which is computed as the total number of bytes used by *this minus the number of bytes used for storing elements divided by the number of values. Dumps the btree to the specified ostream. Requires that operator<< is defined for value. Verifies the structure of *this . Non-member function Swap template <typename K, typename C, typename A, std::size_t N> void swap(btree_multimap<K, C, A, N>& x, btree_multimap<K, C, A, N>& y); Swap x for y using std::swap to swap each member variable of x for that of y .","title":"btree_multimap"},{"location":"reference/btree_multimap/#btree_multimap","text":"In platanus/btree_map.h , namespace platanus { template < typename Key, typename Value, typename Compare = std::ranges::less, typename Alloc = std::allocator<Key>, std::size_t MaxNumOfValues = 512> class btree_multimap; }","title":"btree_multimap"},{"location":"reference/btree_multimap/#template-parameters","text":"Parameter Meaning Key Type of a key Value Type of a value Compare Type of a func obj comparing two key in a weak order. If Key doesn't implement three-way comparison operator, the default type does using < and = . Alloc Type of an allocator. The default is std::allocator<Key> . MaxNumOfValues The max number of values per node. The default is 64.","title":"Template parameters"},{"location":"reference/btree_multimap/#member-types","text":"Type Meaning key_type Type of key, i.e. Key value_type Type of value, i.e. std::pair<const Key, Value> mapped_type Type of mapped value, i.e. Value key_compare Type of comparer of key, i.e. Compare allocator_type Type of allocator, i.e. Alloc pointer Type of pointer to value, i.e. value_type* const_pointer Type of pointer to const value, i.e. const value_type* reference Type of reference to value, i.e. value_type& const_reference Type of reference to const value, i.e. const value_type& size_type Unsigned integer type of size of btree_multimap , i.e. std::size_t difference_type Signed integer type of the difference of two iterators iterator Type of iterator const_iterator Type of const iterator reverse_iterator Type of reverse iterator const_reverse_iterator Type of const reverse iterator","title":"Member types"},{"location":"reference/btree_multimap/#member-function","text":"","title":"Member function"},{"location":"reference/btree_multimap/#constructor","text":"// (1) btree_multimap(); // (2) btree_multimap(const btree_multimap&); // (3) btree_multimap(btree_multimap&&); // (4) explicit btree_multimap(const key_compare& comp, const allocator_type& alloc = allocator_type()); // (5) explicit btree_multimap(const allocator_type& alloc); // (6) template <class InputIterator> btree_multimap( InputIterator b, InputIterator e, const key_compare& comp = key_compare(), const allocator_type& alloc = allocator_type() ); // (7) template <class InputIterator> btree_multimap(InputIterator b, InputIterator e, const allocator_type& alloc); // (8) btree_multimap(const btree_multimap& x, const allocator_type& alloc); // (9) btree_multimap(btree_multimap&& x, const allocator_type& alloc); // (10) btree_multimap( std::initializer_list<value_type> init, const key_compare& comp = key_compare{}, const allocator_type& alloc = allocator_type{} ); // (11) btree_multimap(std::initializer_list<value_type> init, const allocator_type& alloc); // (12) btree_multimap& operator=(const btree_multimap& x); // (13) btree_multimap& operator=(btree_multimap&&) = default; Constructs an empty btree_multimap . Copy constructor. The allocator is copied by std::allocator_traits::select_on_container_copy_construction . Move constructor. The allocator is copied by operator= . Constructs an empty btree_multimap with comp and alloc . Constructs an empty btree_multimap with alloc . Constructs a btree_multimap with comp and alloc by inserting values from b to e ( e isn't included). Constructs a btree_multimap with alloc by inserting values from b to e ( e isn't included). Constructs a copy of x with alloc . Constructs a btree_multimap to which x is moved with alloc . Constructs a btree_multimap with comp and alloc from an initializer list. Constructs a btree_multimap with alloc from an initializer list. Assigns a copy of x and return *this . If x is *this , does nothing. Default move assignment operator.","title":"Constructor"},{"location":"reference/btree_multimap/#iterator","text":"// (1) iterator begin(); // (2) const_iterator begin() const; // (3) const_iterator cbegin() const; // (4) iterator end(); // (5) const_iterator end() const; // (6) const_iterator cend() const; // (7) reverse_iterator rbegin(); // (8) const_reverse_iterator rbegin() const; // (9) const_reverse_iterator crbegin() const; // (10) reverse_iterator rend(); // (11) const_reverse_iterator rend() const; // (12) const_reverse_iterator crend() const; Return the iterator pointing to the first value of *this . The const version of 1. Return the const iterator pointing to the first value of *this . Return the iterator pointing to the next address of the last value of *this . The const version of 4. Return the const iterator pointing to the next address of the last value of *this . Return the reverse iterator pointing to the last value of *this . The const version of 7. Return the const reverse iterator pointing to the last value of *this . Return the reverse iterator pointing to the previous address of the first value of *this . The const version of 10. Return the const reverse iterator pointing to the previous address of the first value of *this .","title":"Iterator"},{"location":"reference/btree_multimap/#modifiers","text":"// (1) void clear(); // (2) void swap(btree_multimap& x); // (3) void merge(btree_multimap& x); // (4) void merge(btree_multimap&& x); Clear *this , i.e., delete all values in *this . Swap *this for x . Merge another btree_multimap . The duplicated values will not be merged to *this . Same as 3. This function is provided to receive an rvalue btree_multimap , so no rvalue-specific optimization is done.","title":"Modifiers"},{"location":"reference/btree_multimap/#insert","text":"// (1) std::pair<iterator, bool> insert(const value_type& x); // (2) std::pair<iterator, bool> insert(value_type&& x); // (3) iterator insert(iterator hint, const value_type& x); // (4) iterator insert(iterator hint, value_type&& x); // (5) template <typename InputIterator> void insert(InputIterator b, InputIterator e); // (6) void insert(std::initializer_list<value_type> list); If there is x in *this , returns an iterator pointing to x in *this and false . Otherwise, inserts x and returns an iterator pointing to x in *this and true . The rvalue version of 1. Does 1 with hint. If the value is placed immediately before hint in the tree, the insertion will take amortized constant time. If not, the insertion will take amortized logarithmic time as if a call to insert(x) were made. The rvalue version of 3. Does 1 for each value from b to e ( e isn't included). Does 1 for each value of list .","title":"insert"},{"location":"reference/btree_multimap/#erase","text":"size_type erase(const key_type& key); iterator erase(const iterator& iter); void erase(const iterator& b, const iterator& e); Erases the specified key from *this and returns Erases the specified iterator from *this . The iterator must be valid (i.e. not equal to end()). Return an iterator pointing to the node after the one that was erased (or end() if none exists). Erases a range from b to e ( e isn't included) and return the number of erased keys.","title":"erase"},{"location":"reference/btree_multimap/#lookup","text":"// (1) iterator lower_bound(const key_type& key); // (2) const_iterator lower_bound(const key_type& key) const; // (3) iterator upper_bound(const key_type& key); // (4) const_iterator upper_bound(const key_type& key) const; // (5) std::pair<iterator, iterator> equal_range(const key_type& key); // (6) std::pair<const_iterator, const_iterator> equal_range(const key_type& key) const; // (7) iterator find(const key_type& key); // (8) const_iterator find(const key_type& key) const; // (9) size_type count(const key_type& key) const; // (10) bool contains(const key_type& key) const; If *this is empty or key isn't found, returns end() . Otherwise, returns an iterator which points to the minimum value in all values which are not less than key . The const version of 1. If *this is empty or key isn't found, returns end() . Otherwise, returns an iterator which points to the minimum value in all values which are greater than key . The const version of 3. If *this is empty or key isn't found, returns end() . Otherwise, returns a pair of the iterators which point to the fist value in all values which are equal to key and the value next to the last value in them in order. The const version of 5. If *this is empty or key isn't found, returns end() . Otherwise, returns an iterator which points to the fist value in all values which are equal to key . The const version of 7. If *this is empty or key isn't found, returns 0 . Otherwise, returns 1 . If *this is empty or key isn't found, returns false . Otherwise, returns true .","title":"Lookup"},{"location":"reference/btree_multimap/#capacity","text":"// (1) size_type size() const; // (2) size_type max_size() const; // (3) bool empty() const; Returns the number of values. Returns the max number of values. Returns a bool whether *this is empty or not.","title":"Capacity"},{"location":"reference/btree_multimap/#observers","text":"key_compare key_comp() const noexcept; Returns the key_compare object used by *this .","title":"Observers"},{"location":"reference/btree_multimap/#non-stl","text":"[WARNING] The following functions may be suddenly deleted. // (1) size_type height() const; // (2) size_type internal_nodes() const; // (3) size_type leaf_nodes() const; // (4) size_type nodes() const; // (5) size_type bytes_used() const; // (6) double average_bytes_per_value() const; // (7) double fullness() const; // (8) double overhead() const; // (9) void dump(std::ostream& os) const; // (10) void verify() const; Returns the hight of *this . Returns the number of internal nodes. Returns the number of leaf nodes. Returns the total of internal nodes and leaf nodes. Returns the total of bytes used by *this . Returns the average bytes per value. Returns the fullness of *this , which is computed as the number of elements in *this divided by the maximum number of elements a tree with the current number of nodes could hold. A value of 1 indicates perfect space utilization. Smaller values indicate space wastage. Returns the overhead of the btree structure in bytes per node, which is computed as the total number of bytes used by *this minus the number of bytes used for storing elements divided by the number of values. Dumps the btree to the specified ostream. Requires that operator<< is defined for value. Verifies the structure of *this .","title":"non-STL"},{"location":"reference/btree_multimap/#non-member-function","text":"","title":"Non-member function"},{"location":"reference/btree_multimap/#swap","text":"template <typename K, typename C, typename A, std::size_t N> void swap(btree_multimap<K, C, A, N>& x, btree_multimap<K, C, A, N>& y); Swap x for y using std::swap to swap each member variable of x for that of y .","title":"Swap"},{"location":"reference/btree_multiset/","text":"btree_multiset In platanus/btree_set.h , namespace platanus { template < typename Key, typename Compare = std::ranges::less, typename Alloc = std::allocator<Key>, std::size_t MaxNumOfValues = 512> class btree_multiset; } Template parameters Parameter Meaning Key Type of a key Compare Type of a func obj comparing two key in a weak order. If Key doesn't implement three-way comparison operator, the default type does using < and = . Alloc Type of an allocator. The default is std::allocator<Key> . MaxNumOfValues The max number of values per node. The default is 64. Member types Type Meaning key_type Type of key, i.e. Key value_type Type of value, i.e. Key key_compare Type of comparer of key, i.e. Compare value_compare Type of comparer of value, i.e. Compare allocator_type Type of allocator, i.e. Alloc pointer Type of pointer to value, i.e. Key* const_pointer Type of pointer to const value, i.e. const Key* reference Type of reference to value, i.e. Key& const_reference Type of reference to const value, i.e. const Key& size_type Unsigned integer type of size of btree_multiset , i.e. std::size_t difference_type Signed integer type of the difference of two iterators iterator Type of iterator const_iterator Type of const iterator reverse_iterator Type of reverse iterator const_reverse_iterator Type of const reverse iterator Member function Constructor // (1) btree_multiset(); // (2) btree_multiset(const btree_multiset&); // (3) btree_multiset(btree_multiset&&); // (4) explicit btree_multiset(const key_compare& comp, const allocator_type& alloc = allocator_type()); // (5) explicit btree_multiset(const allocator_type& alloc); // (6) template <class InputIterator> btree_multiset( InputIterator b, InputIterator e, const key_compare& comp = key_compare(), const allocator_type& alloc = allocator_type() ); // (7) template <class InputIterator> btree_multiset(InputIterator b, InputIterator e, const allocator_type& alloc); // (8) btree_multiset(const btree_multiset& x, const allocator_type& alloc); // (9) btree_multiset(btree_multiset&& x, const allocator_type& alloc); // (10) btree_multiset( std::initializer_list<value_type> init, const key_compare& comp = key_compare{}, const allocator_type& alloc = allocator_type{} ); // (11) btree_multiset(std::initializer_list<value_type> init, const allocator_type& alloc); // (12) btree_multiset& operator=(const btree_multiset& x); // (13) btree_multiset& operator=(btree_multiset&&) = default; Constructs an empty btree_multiset . Copy constructor. The allocator is copied by std::allocator_traits::select_on_container_copy_construction . Move constructor. The allocator is copied by operator= . Constructs an empty btree_multiset with comp and alloc . Constructs an empty btree_multiset with alloc . Constructs a btree_multiset with comp and alloc by inserting values from b to e ( e isn't included). Constructs a btree_multiset with alloc by inserting values from b to e ( e isn't included). Constructs a copy of x with alloc . Constructs a btree_multiset to which x is moved with alloc . Constructs a btree_multiset with comp and alloc from an initializer list. Constructs a btree_multiset with alloc from an initializer list. Assigns a copy of x and return *this . If x is *this , does nothing. Default move assignment operator. Iterator // (1) iterator begin(); // (2) const_iterator begin() const; // (3) const_iterator cbegin() const; // (4) iterator end(); // (5) const_iterator end() const; // (6) const_iterator cend() const; // (7) reverse_iterator rbegin(); // (8) const_reverse_iterator rbegin() const; // (9) const_reverse_iterator crbegin() const; // (10) reverse_iterator rend(); // (11) const_reverse_iterator rend() const; // (12) const_reverse_iterator crend() const; Return the iterator pointing to the first value of *this . The const version of 1. Return the const iterator pointing to the first value of *this . Return the iterator pointing to the next address of the last value of *this . The const version of 4. Return the const iterator pointing to the next address of the last value of *this . Return the reverse iterator pointing to the last value of *this . The const version of 7. Return the const reverse iterator pointing to the last value of *this . Return the reverse iterator pointing to the previous address of the first value of *this . The const version of 10. Return the const reverse iterator pointing to the previous address of the first value of *this . Modifiers // (1) void clear(); // (2) void swap(btree_multiset& x); // (3) void merge(btree_multiset& x); // (4) void merge(btree_multiset&& x); Clear *this , i.e., delete all values in *this . Swap *this for x . Merge another btree_multiset . The duplicated values will not be merged to *this . Same as 3. This function is provided to receive an rvalue btree_multiset , so no rvalue-specific optimization is done. insert // (1) std::pair<iterator, bool> insert(const value_type& x); // (2) std::pair<iterator, bool> insert(value_type&& x); // (3) iterator insert(iterator hint, const value_type& x); // (4) iterator insert(iterator hint, value_type&& x); // (5) template <typename InputIterator> void insert(InputIterator b, InputIterator e); // (6) void insert(std::initializer_list<value_type> list); If there is x in *this , returns an iterator pointing to x in *this and false . Otherwise, inserts x and returns an iterator pointing to x in *this and true . The rvalue version of 1. Does 1 with hint. If the value is placed immediately before hint in the tree, the insertion will take amortized constant time. If not, the insertion will take amortized logarithmic time as if a call to insert(x) were made. The rvalue version of 3. Does 1 for each value from b to e ( e isn't included). Does 1 for each value of list . erase size_type erase(const key_type& key); iterator erase(const iterator& iter); void erase(const iterator& b, const iterator& e); Erases the specified key from *this and returns Erases the specified iterator from *this . The iterator must be valid (i.e. not equal to end()). Return an iterator pointing to the node after the one that was erased (or end() if none exists). Erases a range from b to e ( e isn't included) and return the number of erased keys. Lookup // (1) iterator lower_bound(const key_type& key); // (2) const_iterator lower_bound(const key_type& key) const; // (3) iterator upper_bound(const key_type& key); // (4) const_iterator upper_bound(const key_type& key) const; // (5) std::pair<iterator, iterator> equal_range(const key_type& key); // (6) std::pair<const_iterator, const_iterator> equal_range(const key_type& key) const; // (7) iterator find(const key_type& key); // (8) const_iterator find(const key_type& key) const; // (9) size_type count(const key_type& key) const; // (10) bool contains(const key_type& key) const; If *this is empty or key isn't found, returns end() . Otherwise, returns an iterator which points to the first value in all values which are not less than key . The const version of 1. If *this is empty or key isn't found, returns end() . Otherwise, returns an iterator which points to the first value in all values which are greater than key . The const version of 3. If *this is empty or key isn't found, returns end() . Otherwise, returns a pair of the iterators which point to the fist value in all values which are equal to key and the value next to the last value in them in order. The const version of 5. If *this is empty or key isn't found, returns end() . Otherwise, returns an iterator which points to the fist value in all values which are equal to key . The const version of 7. If *this is empty or key isn't found, returns 0 . Otherwise, returns the number of key . If *this is empty or key isn't found, returns false . Otherwise, returns true . Capacity // (1) size_type size() const; // (2) size_type max_size() const; // (3) bool empty() const; Returns the number of values. Returns the max number of values. Returns a bool whether *this is empty or not. Observers key_compare key_comp() const noexcept; Returns the key_compare object used by *this . non-STL [WARNING] The following functions may be suddenly deleted. // (1) size_type height() const; // (2) size_type internal_nodes() const; // (3) size_type leaf_nodes() const; // (4) size_type nodes() const; // (5) size_type bytes_used() const; // (6) double average_bytes_per_value() const; // (7) double fullness() const; // (8) double overhead() const; // (9) void dump(std::ostream& os) const; // (10) void verify() const; Returns the hight of *this . Returns the number of internal nodes. Returns the number of leaf nodes. Returns the total of internal nodes and leaf nodes. Returns the total of bytes used by *this . Returns the average bytes per value. Returns the fullness of *this , which is computed as the number of elements in *this divided by the maximum number of elements a tree with the current number of nodes could hold. A value of 1 indicates perfect space utilization. Smaller values indicate space wastage. Returns the overhead of the btree structure in bytes per node, which is computed as the total number of bytes used by *this minus the number of bytes used for storing elements divided by the number of values. Dumps the btree to the specified ostream. Requires that operator<< is defined for value. Verifies the structure of *this . Non-member function Swap template <typename K, typename C, typename A, std::size_t N> void swap(btree_multiset<K, C, A, N>& x, btree_multiset<K, C, A, N>& y); Swap x for y using std::swap to swap each member variable of x for that of y .","title":"btree_multiset"},{"location":"reference/btree_multiset/#btree_multiset","text":"In platanus/btree_set.h , namespace platanus { template < typename Key, typename Compare = std::ranges::less, typename Alloc = std::allocator<Key>, std::size_t MaxNumOfValues = 512> class btree_multiset; }","title":"btree_multiset"},{"location":"reference/btree_multiset/#template-parameters","text":"Parameter Meaning Key Type of a key Compare Type of a func obj comparing two key in a weak order. If Key doesn't implement three-way comparison operator, the default type does using < and = . Alloc Type of an allocator. The default is std::allocator<Key> . MaxNumOfValues The max number of values per node. The default is 64.","title":"Template parameters"},{"location":"reference/btree_multiset/#member-types","text":"Type Meaning key_type Type of key, i.e. Key value_type Type of value, i.e. Key key_compare Type of comparer of key, i.e. Compare value_compare Type of comparer of value, i.e. Compare allocator_type Type of allocator, i.e. Alloc pointer Type of pointer to value, i.e. Key* const_pointer Type of pointer to const value, i.e. const Key* reference Type of reference to value, i.e. Key& const_reference Type of reference to const value, i.e. const Key& size_type Unsigned integer type of size of btree_multiset , i.e. std::size_t difference_type Signed integer type of the difference of two iterators iterator Type of iterator const_iterator Type of const iterator reverse_iterator Type of reverse iterator const_reverse_iterator Type of const reverse iterator","title":"Member types"},{"location":"reference/btree_multiset/#member-function","text":"","title":"Member function"},{"location":"reference/btree_multiset/#constructor","text":"// (1) btree_multiset(); // (2) btree_multiset(const btree_multiset&); // (3) btree_multiset(btree_multiset&&); // (4) explicit btree_multiset(const key_compare& comp, const allocator_type& alloc = allocator_type()); // (5) explicit btree_multiset(const allocator_type& alloc); // (6) template <class InputIterator> btree_multiset( InputIterator b, InputIterator e, const key_compare& comp = key_compare(), const allocator_type& alloc = allocator_type() ); // (7) template <class InputIterator> btree_multiset(InputIterator b, InputIterator e, const allocator_type& alloc); // (8) btree_multiset(const btree_multiset& x, const allocator_type& alloc); // (9) btree_multiset(btree_multiset&& x, const allocator_type& alloc); // (10) btree_multiset( std::initializer_list<value_type> init, const key_compare& comp = key_compare{}, const allocator_type& alloc = allocator_type{} ); // (11) btree_multiset(std::initializer_list<value_type> init, const allocator_type& alloc); // (12) btree_multiset& operator=(const btree_multiset& x); // (13) btree_multiset& operator=(btree_multiset&&) = default; Constructs an empty btree_multiset . Copy constructor. The allocator is copied by std::allocator_traits::select_on_container_copy_construction . Move constructor. The allocator is copied by operator= . Constructs an empty btree_multiset with comp and alloc . Constructs an empty btree_multiset with alloc . Constructs a btree_multiset with comp and alloc by inserting values from b to e ( e isn't included). Constructs a btree_multiset with alloc by inserting values from b to e ( e isn't included). Constructs a copy of x with alloc . Constructs a btree_multiset to which x is moved with alloc . Constructs a btree_multiset with comp and alloc from an initializer list. Constructs a btree_multiset with alloc from an initializer list. Assigns a copy of x and return *this . If x is *this , does nothing. Default move assignment operator.","title":"Constructor"},{"location":"reference/btree_multiset/#iterator","text":"// (1) iterator begin(); // (2) const_iterator begin() const; // (3) const_iterator cbegin() const; // (4) iterator end(); // (5) const_iterator end() const; // (6) const_iterator cend() const; // (7) reverse_iterator rbegin(); // (8) const_reverse_iterator rbegin() const; // (9) const_reverse_iterator crbegin() const; // (10) reverse_iterator rend(); // (11) const_reverse_iterator rend() const; // (12) const_reverse_iterator crend() const; Return the iterator pointing to the first value of *this . The const version of 1. Return the const iterator pointing to the first value of *this . Return the iterator pointing to the next address of the last value of *this . The const version of 4. Return the const iterator pointing to the next address of the last value of *this . Return the reverse iterator pointing to the last value of *this . The const version of 7. Return the const reverse iterator pointing to the last value of *this . Return the reverse iterator pointing to the previous address of the first value of *this . The const version of 10. Return the const reverse iterator pointing to the previous address of the first value of *this .","title":"Iterator"},{"location":"reference/btree_multiset/#modifiers","text":"// (1) void clear(); // (2) void swap(btree_multiset& x); // (3) void merge(btree_multiset& x); // (4) void merge(btree_multiset&& x); Clear *this , i.e., delete all values in *this . Swap *this for x . Merge another btree_multiset . The duplicated values will not be merged to *this . Same as 3. This function is provided to receive an rvalue btree_multiset , so no rvalue-specific optimization is done.","title":"Modifiers"},{"location":"reference/btree_multiset/#insert","text":"// (1) std::pair<iterator, bool> insert(const value_type& x); // (2) std::pair<iterator, bool> insert(value_type&& x); // (3) iterator insert(iterator hint, const value_type& x); // (4) iterator insert(iterator hint, value_type&& x); // (5) template <typename InputIterator> void insert(InputIterator b, InputIterator e); // (6) void insert(std::initializer_list<value_type> list); If there is x in *this , returns an iterator pointing to x in *this and false . Otherwise, inserts x and returns an iterator pointing to x in *this and true . The rvalue version of 1. Does 1 with hint. If the value is placed immediately before hint in the tree, the insertion will take amortized constant time. If not, the insertion will take amortized logarithmic time as if a call to insert(x) were made. The rvalue version of 3. Does 1 for each value from b to e ( e isn't included). Does 1 for each value of list .","title":"insert"},{"location":"reference/btree_multiset/#erase","text":"size_type erase(const key_type& key); iterator erase(const iterator& iter); void erase(const iterator& b, const iterator& e); Erases the specified key from *this and returns Erases the specified iterator from *this . The iterator must be valid (i.e. not equal to end()). Return an iterator pointing to the node after the one that was erased (or end() if none exists). Erases a range from b to e ( e isn't included) and return the number of erased keys.","title":"erase"},{"location":"reference/btree_multiset/#lookup","text":"// (1) iterator lower_bound(const key_type& key); // (2) const_iterator lower_bound(const key_type& key) const; // (3) iterator upper_bound(const key_type& key); // (4) const_iterator upper_bound(const key_type& key) const; // (5) std::pair<iterator, iterator> equal_range(const key_type& key); // (6) std::pair<const_iterator, const_iterator> equal_range(const key_type& key) const; // (7) iterator find(const key_type& key); // (8) const_iterator find(const key_type& key) const; // (9) size_type count(const key_type& key) const; // (10) bool contains(const key_type& key) const; If *this is empty or key isn't found, returns end() . Otherwise, returns an iterator which points to the first value in all values which are not less than key . The const version of 1. If *this is empty or key isn't found, returns end() . Otherwise, returns an iterator which points to the first value in all values which are greater than key . The const version of 3. If *this is empty or key isn't found, returns end() . Otherwise, returns a pair of the iterators which point to the fist value in all values which are equal to key and the value next to the last value in them in order. The const version of 5. If *this is empty or key isn't found, returns end() . Otherwise, returns an iterator which points to the fist value in all values which are equal to key . The const version of 7. If *this is empty or key isn't found, returns 0 . Otherwise, returns the number of key . If *this is empty or key isn't found, returns false . Otherwise, returns true .","title":"Lookup"},{"location":"reference/btree_multiset/#capacity","text":"// (1) size_type size() const; // (2) size_type max_size() const; // (3) bool empty() const; Returns the number of values. Returns the max number of values. Returns a bool whether *this is empty or not.","title":"Capacity"},{"location":"reference/btree_multiset/#observers","text":"key_compare key_comp() const noexcept; Returns the key_compare object used by *this .","title":"Observers"},{"location":"reference/btree_multiset/#non-stl","text":"[WARNING] The following functions may be suddenly deleted. // (1) size_type height() const; // (2) size_type internal_nodes() const; // (3) size_type leaf_nodes() const; // (4) size_type nodes() const; // (5) size_type bytes_used() const; // (6) double average_bytes_per_value() const; // (7) double fullness() const; // (8) double overhead() const; // (9) void dump(std::ostream& os) const; // (10) void verify() const; Returns the hight of *this . Returns the number of internal nodes. Returns the number of leaf nodes. Returns the total of internal nodes and leaf nodes. Returns the total of bytes used by *this . Returns the average bytes per value. Returns the fullness of *this , which is computed as the number of elements in *this divided by the maximum number of elements a tree with the current number of nodes could hold. A value of 1 indicates perfect space utilization. Smaller values indicate space wastage. Returns the overhead of the btree structure in bytes per node, which is computed as the total number of bytes used by *this minus the number of bytes used for storing elements divided by the number of values. Dumps the btree to the specified ostream. Requires that operator<< is defined for value. Verifies the structure of *this .","title":"non-STL"},{"location":"reference/btree_multiset/#non-member-function","text":"","title":"Non-member function"},{"location":"reference/btree_multiset/#swap","text":"template <typename K, typename C, typename A, std::size_t N> void swap(btree_multiset<K, C, A, N>& x, btree_multiset<K, C, A, N>& y); Swap x for y using std::swap to swap each member variable of x for that of y .","title":"Swap"},{"location":"reference/btree_set/","text":"btree_set In platanus/btree_set.h , namespace platanus { template < typename Key, typename Compare = std::ranges::less, typename Alloc = std::allocator<Key>, std::size_t MaxNumOfValues = 512> class btree_set; } Template parameters Parameter Meaning Key Type of a key Compare Type of a func obj comparing two key in a weak order. If Key doesn't implement three-way comparison operator, the default type does using < and = . Alloc Type of an allocator. The default is std::allocator<Key> . MaxNumOfValues The max number of values per node. The default is 64. Member types Type Meaning key_type Type of key, i.e. Key value_type Type of value, i.e. Key key_compare Type of comparer of key, i.e. Compare value_compare Type of comparer of value, i.e. Compare allocator_type Type of allocator, i.e. Alloc pointer Type of pointer to value, i.e. Key* const_pointer Type of pointer to const value, i.e. const Key* reference Type of reference to value, i.e. Key& const_reference Type of reference to const value, i.e. const Key& size_type Unsigned integer type of size of btree_set , i.e. std::size_t difference_type Signed integer type of the difference of two iterators iterator Type of iterator const_iterator Type of const iterator reverse_iterator Type of reverse iterator const_reverse_iterator Type of const reverse iterator Member function Constructor // (1) btree_set(); // (2) btree_set(const btree_set&); // (3) btree_set(btree_set&&); // (4) explicit btree_set(const key_compare& comp, const allocator_type& alloc = allocator_type()); // (5) explicit btree_set(const allocator_type& alloc); // (6) template <class InputIterator> btree_set( InputIterator b, InputIterator e, const key_compare& comp = key_compare(), const allocator_type& alloc = allocator_type() ); // (7) template <class InputIterator> btree_set(InputIterator b, InputIterator e, const allocator_type& alloc); // (8) btree_set(const btree_set& x, const allocator_type& alloc); // (9) btree_set(btree_set&& x, const allocator_type& alloc); // (10) btree_set( std::initializer_list<value_type> init, const key_compare& comp = key_compare{}, const allocator_type& alloc = allocator_type{} ); // (11) btree_set(std::initializer_list<value_type> init, const allocator_type& alloc); // (12) btree_set& operator=(const btree_set& x); // (13) btree_set& operator=(btree_set&&) = default; Constructs an empty btree_set . Copy constructor. The allocator is copied by std::allocator_traits::select_on_container_copy_construction . Move constructor. The allocator is copied by operator= . Constructs an empty btree_set with comp and alloc . Constructs an empty btree_set with alloc . Constructs a btree_set with comp and alloc by inserting values from b to e ( e isn't included). Constructs a btree_set with alloc by inserting values from b to e ( e isn't included). Constructs a copy of x with alloc . Constructs a btree_set to which x is moved with alloc . Constructs a btree_set with comp and alloc from an initializer list. Constructs a btree_set with alloc from an initializer list. Assigns a copy of x and return *this . If x is *this , does nothing. Default move assignment operator. Iterator // (1) iterator begin(); // (2) const_iterator begin() const; // (3) const_iterator cbegin() const; // (4) iterator end(); // (5) const_iterator end() const; // (6) const_iterator cend() const; // (7) reverse_iterator rbegin(); // (8) const_reverse_iterator rbegin() const; // (9) const_reverse_iterator crbegin() const; // (10) reverse_iterator rend(); // (11) const_reverse_iterator rend() const; // (12) const_reverse_iterator crend() const; Return the iterator pointing to the first value of *this . The const version of 1. Return the const iterator pointing to the first value of *this . Return the iterator pointing to the next address of the last value of *this . The const version of 4. Return the const iterator pointing to the next address of the last value of *this . Return the reverse iterator pointing to the last value of *this . The const version of 7. Return the const reverse iterator pointing to the last value of *this . Return the reverse iterator pointing to the previous address of the first value of *this . The const version of 10. Return the const reverse iterator pointing to the previous address of the first value of *this . Modifiers // (1) void clear(); // (2) void swap(btree_set& x); // (3) void merge(btree_set& x); // (4) void merge(btree_set&& x); Clear *this , i.e., delete all values in *this . Swap *this for x . Merge another btree_set . The duplicated values will not be merged to *this . Same as 3. This function is provided to receive an rvalue btree_set , so no rvalue-specific optimization is done. insert // (1) std::pair<iterator, bool> insert(const value_type& x); // (2) std::pair<iterator, bool> insert(value_type&& x); // (3) iterator insert(iterator hint, const value_type& x); // (4) iterator insert(iterator hint, value_type&& x); // (5) template <typename InputIterator> void insert(InputIterator b, InputIterator e); // (6) void insert(std::initializer_list<value_type> list); If there is x in *this , returns an iterator pointing to x in *this and false . Otherwise, inserts x and returns an iterator pointing to x in *this and true . The rvalue version of 1. Does 1 with hint. If the value is placed immediately before hint in the tree, the insertion will take amortized constant time. If not, the insertion will take amortized logarithmic time as if a call to insert(x) were made. The rvalue version of 3. Does 1 for each value from b to e ( e isn't included). Does 1 for each value of list . erase size_type erase(const key_type& key); iterator erase(const iterator& iter); void erase(const iterator& b, const iterator& e); Erases the specified key from *this and returns Erases the specified iterator from *this . The iterator must be valid (i.e. not equal to end()). Return an iterator pointing to the node after the one that was erased (or end() if none exists). Erases a range from b to e ( e isn't included) and return the number of erased keys. Lookup // (1) iterator lower_bound(const key_type& key); // (2) const_iterator lower_bound(const key_type& key) const; // (3) iterator upper_bound(const key_type& key); // (4) const_iterator upper_bound(const key_type& key) const; // (5) std::pair<iterator, iterator> equal_range(const key_type& key); // (6) std::pair<const_iterator, const_iterator> equal_range(const key_type& key) const; // (7) iterator find(const key_type& key); // (8) const_iterator find(const key_type& key) const; // (9) size_type count(const key_type& key) const; // (10) bool contains(const key_type& key) const; If *this is empty or key isn't found, returns end() . Otherwise, returns an iterator which points to the minimum value in all values which are not less than key . The const version of 1. If *this is empty or key isn't found, returns end() . Otherwise, returns an iterator which points to the minimum value in all values which are greater than key . The const version of 3. If *this is empty or key isn't found, returns end() . Otherwise, returns a pair of the iterators which point to the fist value in all values which are equal to key and the value next to the last value in them in order. The const version of 5. If *this is empty or key isn't found, returns end() . Otherwise, returns an iterator which points to the fist value in all values which are equal to key . The const version of 7. If *this is empty or key isn't found, returns 0 . Otherwise, returns 1 . If *this is empty or key isn't found, returns false . Otherwise, returns true . Capacity // (1) size_type size() const; // (2) size_type max_size() const; // (3) bool empty() const; Returns the number of values. Returns the max number of values. Returns a bool whether *this is empty or not. Observers key_compare key_comp() const noexcept; Returns the key_compare object used by *this . non-STL [WARNING] The following functions may be suddenly deleted. // (1) size_type height() const; // (2) size_type internal_nodes() const; // (3) size_type leaf_nodes() const; // (4) size_type nodes() const; // (5) size_type bytes_used() const; // (6) double average_bytes_per_value() const; // (7) double fullness() const; // (8) double overhead() const; // (9) void dump(std::ostream& os) const; // (10) void verify() const; Returns the hight of *this . Returns the number of internal nodes. Returns the number of leaf nodes. Returns the total of internal nodes and leaf nodes. Returns the total of bytes used by *this . Returns the average bytes per value. Returns the fullness of *this , which is computed as the number of elements in *this divided by the maximum number of elements a tree with the current number of nodes could hold. A value of 1 indicates perfect space utilization. Smaller values indicate space wastage. Returns the overhead of the btree structure in bytes per node, which is computed as the total number of bytes used by *this minus the number of bytes used for storing elements divided by the number of values. Dumps the btree to the specified ostream. Requires that operator<< is defined for value. Verifies the structure of *this . Non-member function Swap template <typename K, typename C, typename A, std::size_t N> void swap(btree_set<K, C, A, N>& x, btree_set<K, C, A, N>& y); Swap x for y using std::swap to swap each member variable of x for that of y .","title":"btree_set"},{"location":"reference/btree_set/#btree_set","text":"In platanus/btree_set.h , namespace platanus { template < typename Key, typename Compare = std::ranges::less, typename Alloc = std::allocator<Key>, std::size_t MaxNumOfValues = 512> class btree_set; }","title":"btree_set"},{"location":"reference/btree_set/#template-parameters","text":"Parameter Meaning Key Type of a key Compare Type of a func obj comparing two key in a weak order. If Key doesn't implement three-way comparison operator, the default type does using < and = . Alloc Type of an allocator. The default is std::allocator<Key> . MaxNumOfValues The max number of values per node. The default is 64.","title":"Template parameters"},{"location":"reference/btree_set/#member-types","text":"Type Meaning key_type Type of key, i.e. Key value_type Type of value, i.e. Key key_compare Type of comparer of key, i.e. Compare value_compare Type of comparer of value, i.e. Compare allocator_type Type of allocator, i.e. Alloc pointer Type of pointer to value, i.e. Key* const_pointer Type of pointer to const value, i.e. const Key* reference Type of reference to value, i.e. Key& const_reference Type of reference to const value, i.e. const Key& size_type Unsigned integer type of size of btree_set , i.e. std::size_t difference_type Signed integer type of the difference of two iterators iterator Type of iterator const_iterator Type of const iterator reverse_iterator Type of reverse iterator const_reverse_iterator Type of const reverse iterator","title":"Member types"},{"location":"reference/btree_set/#member-function","text":"","title":"Member function"},{"location":"reference/btree_set/#constructor","text":"// (1) btree_set(); // (2) btree_set(const btree_set&); // (3) btree_set(btree_set&&); // (4) explicit btree_set(const key_compare& comp, const allocator_type& alloc = allocator_type()); // (5) explicit btree_set(const allocator_type& alloc); // (6) template <class InputIterator> btree_set( InputIterator b, InputIterator e, const key_compare& comp = key_compare(), const allocator_type& alloc = allocator_type() ); // (7) template <class InputIterator> btree_set(InputIterator b, InputIterator e, const allocator_type& alloc); // (8) btree_set(const btree_set& x, const allocator_type& alloc); // (9) btree_set(btree_set&& x, const allocator_type& alloc); // (10) btree_set( std::initializer_list<value_type> init, const key_compare& comp = key_compare{}, const allocator_type& alloc = allocator_type{} ); // (11) btree_set(std::initializer_list<value_type> init, const allocator_type& alloc); // (12) btree_set& operator=(const btree_set& x); // (13) btree_set& operator=(btree_set&&) = default; Constructs an empty btree_set . Copy constructor. The allocator is copied by std::allocator_traits::select_on_container_copy_construction . Move constructor. The allocator is copied by operator= . Constructs an empty btree_set with comp and alloc . Constructs an empty btree_set with alloc . Constructs a btree_set with comp and alloc by inserting values from b to e ( e isn't included). Constructs a btree_set with alloc by inserting values from b to e ( e isn't included). Constructs a copy of x with alloc . Constructs a btree_set to which x is moved with alloc . Constructs a btree_set with comp and alloc from an initializer list. Constructs a btree_set with alloc from an initializer list. Assigns a copy of x and return *this . If x is *this , does nothing. Default move assignment operator.","title":"Constructor"},{"location":"reference/btree_set/#iterator","text":"// (1) iterator begin(); // (2) const_iterator begin() const; // (3) const_iterator cbegin() const; // (4) iterator end(); // (5) const_iterator end() const; // (6) const_iterator cend() const; // (7) reverse_iterator rbegin(); // (8) const_reverse_iterator rbegin() const; // (9) const_reverse_iterator crbegin() const; // (10) reverse_iterator rend(); // (11) const_reverse_iterator rend() const; // (12) const_reverse_iterator crend() const; Return the iterator pointing to the first value of *this . The const version of 1. Return the const iterator pointing to the first value of *this . Return the iterator pointing to the next address of the last value of *this . The const version of 4. Return the const iterator pointing to the next address of the last value of *this . Return the reverse iterator pointing to the last value of *this . The const version of 7. Return the const reverse iterator pointing to the last value of *this . Return the reverse iterator pointing to the previous address of the first value of *this . The const version of 10. Return the const reverse iterator pointing to the previous address of the first value of *this .","title":"Iterator"},{"location":"reference/btree_set/#modifiers","text":"// (1) void clear(); // (2) void swap(btree_set& x); // (3) void merge(btree_set& x); // (4) void merge(btree_set&& x); Clear *this , i.e., delete all values in *this . Swap *this for x . Merge another btree_set . The duplicated values will not be merged to *this . Same as 3. This function is provided to receive an rvalue btree_set , so no rvalue-specific optimization is done.","title":"Modifiers"},{"location":"reference/btree_set/#insert","text":"// (1) std::pair<iterator, bool> insert(const value_type& x); // (2) std::pair<iterator, bool> insert(value_type&& x); // (3) iterator insert(iterator hint, const value_type& x); // (4) iterator insert(iterator hint, value_type&& x); // (5) template <typename InputIterator> void insert(InputIterator b, InputIterator e); // (6) void insert(std::initializer_list<value_type> list); If there is x in *this , returns an iterator pointing to x in *this and false . Otherwise, inserts x and returns an iterator pointing to x in *this and true . The rvalue version of 1. Does 1 with hint. If the value is placed immediately before hint in the tree, the insertion will take amortized constant time. If not, the insertion will take amortized logarithmic time as if a call to insert(x) were made. The rvalue version of 3. Does 1 for each value from b to e ( e isn't included). Does 1 for each value of list .","title":"insert"},{"location":"reference/btree_set/#erase","text":"size_type erase(const key_type& key); iterator erase(const iterator& iter); void erase(const iterator& b, const iterator& e); Erases the specified key from *this and returns Erases the specified iterator from *this . The iterator must be valid (i.e. not equal to end()). Return an iterator pointing to the node after the one that was erased (or end() if none exists). Erases a range from b to e ( e isn't included) and return the number of erased keys.","title":"erase"},{"location":"reference/btree_set/#lookup","text":"// (1) iterator lower_bound(const key_type& key); // (2) const_iterator lower_bound(const key_type& key) const; // (3) iterator upper_bound(const key_type& key); // (4) const_iterator upper_bound(const key_type& key) const; // (5) std::pair<iterator, iterator> equal_range(const key_type& key); // (6) std::pair<const_iterator, const_iterator> equal_range(const key_type& key) const; // (7) iterator find(const key_type& key); // (8) const_iterator find(const key_type& key) const; // (9) size_type count(const key_type& key) const; // (10) bool contains(const key_type& key) const; If *this is empty or key isn't found, returns end() . Otherwise, returns an iterator which points to the minimum value in all values which are not less than key . The const version of 1. If *this is empty or key isn't found, returns end() . Otherwise, returns an iterator which points to the minimum value in all values which are greater than key . The const version of 3. If *this is empty or key isn't found, returns end() . Otherwise, returns a pair of the iterators which point to the fist value in all values which are equal to key and the value next to the last value in them in order. The const version of 5. If *this is empty or key isn't found, returns end() . Otherwise, returns an iterator which points to the fist value in all values which are equal to key . The const version of 7. If *this is empty or key isn't found, returns 0 . Otherwise, returns 1 . If *this is empty or key isn't found, returns false . Otherwise, returns true .","title":"Lookup"},{"location":"reference/btree_set/#capacity","text":"// (1) size_type size() const; // (2) size_type max_size() const; // (3) bool empty() const; Returns the number of values. Returns the max number of values. Returns a bool whether *this is empty or not.","title":"Capacity"},{"location":"reference/btree_set/#observers","text":"key_compare key_comp() const noexcept; Returns the key_compare object used by *this .","title":"Observers"},{"location":"reference/btree_set/#non-stl","text":"[WARNING] The following functions may be suddenly deleted. // (1) size_type height() const; // (2) size_type internal_nodes() const; // (3) size_type leaf_nodes() const; // (4) size_type nodes() const; // (5) size_type bytes_used() const; // (6) double average_bytes_per_value() const; // (7) double fullness() const; // (8) double overhead() const; // (9) void dump(std::ostream& os) const; // (10) void verify() const; Returns the hight of *this . Returns the number of internal nodes. Returns the number of leaf nodes. Returns the total of internal nodes and leaf nodes. Returns the total of bytes used by *this . Returns the average bytes per value. Returns the fullness of *this , which is computed as the number of elements in *this divided by the maximum number of elements a tree with the current number of nodes could hold. A value of 1 indicates perfect space utilization. Smaller values indicate space wastage. Returns the overhead of the btree structure in bytes per node, which is computed as the total number of bytes used by *this minus the number of bytes used for storing elements divided by the number of values. Dumps the btree to the specified ostream. Requires that operator<< is defined for value. Verifies the structure of *this .","title":"non-STL"},{"location":"reference/btree_set/#non-member-function","text":"","title":"Non-member function"},{"location":"reference/btree_set/#swap","text":"template <typename K, typename C, typename A, std::size_t N> void swap(btree_set<K, C, A, N>& x, btree_set<K, C, A, N>& y); Swap x for y using std::swap to swap each member variable of x for that of y .","title":"Swap"}]}