{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#platanus","title":"platanus","text":"<p><code>platanus</code> is a fork of the B-tree library <code>cpp-btree</code>.</p>"},{"location":"#comparing-to-stl-setmap","title":"Comparing to STL set/map","text":"<p>A btree is both smaller and faster than STL set/map. The red-black tree implementation of STL set/map has an overhead of 3 pointers (left, right and parent) plus the node color information for each stored value. So a <code>std::set&lt;std::int32_t&gt;</code> consumes 32 bytes for each value stored. This btree implementation stores the fixed number of values on a nodes (usually 64) and doesn't store child pointers for leaf nodes. The result is that a <code>platanus::btree_set&lt;std::int32&gt;</code> may use much less memory per stored value. For the random insertion benchmark, a <code>platanus::btree_set&lt;std::int32_t&gt;</code> with 64 values per node uses 4.64 bytes per stored value.</p> <p>The packing of multiple values into nodes of a btree has another effect besides better space utilization: better cache locality due to fewer cache lines being accessed, that is, faster operations.</p>"},{"location":"#feature","title":"Feature","text":"<ul> <li>satisfying alignment requirement,</li> <li>supporting stateful comparer,</li> <li>the standard C++ container-like interface,</li> <li>supporting CMake,</li> <li>easier to read than the original,</li> <li>supporting three-way comparison operator,</li> <li>supporting <code>std::pmr::polymorphic_allocator</code> (in <code>platanus::pmr</code> namespace).</li> </ul>"},{"location":"#performance","title":"Performance","text":"<p>Generally speaking, <code>platunus</code> is slower than <code>cpp-btree</code> by approximately 13%.</p> <p>However, <code>platunus</code> is faster than <code>std::(multi)set</code> and <code>std::(multi)map</code> by approximately 59% (the values are median and the order of B-tree is 65 (default)). Forwarding an iterator of <code>platanus</code> is extremely faster than doing that of STL, while FIFO of <code>platanus</code> is slower than that of STL by approximately 19%. So, you should select an appropriate one matching your use case.</p>"},{"location":"#limitation-and-caveats","title":"Limitation and caveats","text":""},{"location":"#supporting-the-orders-of-b-tree","title":"Supporting the orders of B-Tree","text":"<p>We need at least 3 values per a node in order to perform splitting (1 value for the two nodes involved in the split and 1 value propagated to the parent as the delimiter for the split). That is, We don't support the 3 order B-trees.</p>"},{"location":"#invalidating-iterators-after-insertions-and-deletions","title":"Invalidating iterators after insertions and deletions","text":"<p>Insertions and deletions on a btree can cause splitting, merging or rebalancing of btree nodes. And even without these operations, insertions and deletions on a btree will move values around within a node. In both cases, the result is that insertions and deletions can invalidate iterators pointing to values other than the one being inserted/deleted. This is notably different from STL set/map which takes care to not invalidate iterators on <code>insert</code>/<code>erase</code> except, of course, for iterators pointing to the value being erased. A partial workaround when erasing is available: <code>erase()</code> returns an iterator pointing to the item just after the one that was erased (or <code>end()</code> if none exists).</p>"},{"location":"#thread-safety","title":"Thread-safety","text":"<p>All functions and classes in this library are not thread-safe.</p>"},{"location":"#installation","title":"Installation","text":"<p><code>platanus</code> is an header only library, so you don't have to install it. When using CMake, you only have to link your program to <code>platanus::platanus</code>. For example, <code>target_link_libraries(your_program PUBLIC platanus::platanus)</code>.</p>"},{"location":"#test","title":"Test","text":"<p>If you want to test, for example, run the following commands in the top directory of <code>platanus</code>. </p><pre><code>cmake -S . -B build/debug --preset test\ncd build/debug/test\n./btree_test\n</code></pre><p></p>"},{"location":"#performance-test","title":"Performance test","text":"<p>If you want to check how much <code>platanus</code> is faster than STL, run the following commands.</p> <pre><code>cmake -S . -B build/release -DPLATANUS_BUILD_BENCHMARK=ON -DCMAKE_BUILD_TYPE=Release\ncd build/release/benchmark\n./btree_bench\n</code></pre> <p>The output has the following form.</p> <pre><code>BM_&lt;(\"STL\" or \"BTree\")(container type)&lt;(value type)[, (the max number of values per node)]&gt;&gt; (average time[ns] per iteration) (average CPU time[ns] per iteration) (the total of iterations)\n</code></pre> <p>The test cases are:</p> test case meaning Insert Benchmark insertion of random values into an empty container. Lookup Benchmark lookup of random values in a container. Delete Benchmark deletion of random values from a container. FwdIter Benchmark iteration (forward) and reference through the container. Note that this benchmark includes a copy constructing of <code>key_type</code>. Merge Benchmark merging two containers with the same size. <p>If you want to know a good size of values per node, run the following comamnd.</p> <pre><code>cmake -S . -B build/release -DPLATANUS_BUILD_BENCHMARK=ON -DCMAKE_BUILD_TYPE=Release -DPLATANUS_VALUES_SIZE_TEST\ncd build/release/benchmark\n./btree_bench\n</code></pre>"},{"location":"#license","title":"License","text":"<p><code>platanus</code> is licensed under Apache License, Version 2.0.</p>"},{"location":"reference/btree_map/","title":"btree_map","text":""},{"location":"reference/btree_map/#btree_map","title":"btree_map","text":"<p>In <code>platanus/btree_map.hpp</code>,</p> <pre><code>namespace platanus {\ntemplate &lt;\n    typename Key,\n    typename Value,\n    typename Compare           = std::ranges::less,\n    typename Alloc             = std::allocator&lt;Key&gt;,\n    std::size_t MaxNumOfValues = 512&gt;\nclass btree_map;\n}\n</code></pre>"},{"location":"reference/btree_map/#template-parameters","title":"Template parameters","text":"Parameter Meaning <code>Key</code> Type of a key <code>Value</code> Type of a value <code>Compare</code> Type of a func obj comparing two key in a weak order. If Key doesn't implement three-way comparison operator, the default type does using <code>&lt;</code> and <code>=</code>. <code>Alloc</code> Type of an allocator. The default is <code>std::allocator&lt;Key&gt;</code>. <code>MaxNumOfValues</code> The max number of values per node. The default is 64."},{"location":"reference/btree_map/#member-types","title":"Member types","text":"Type Meaning key_type Type of key, i.e. <code>Key</code> value_type Type of value, i.e. <code>std::pair&lt;const Key, Value&gt;</code> mapped_type Type of mapped value, i.e. <code>Value</code> key_compare Type of comparer of key, i.e. <code>Compare</code> allocator_type Type of allocator, i.e. <code>Alloc</code> pointer Type of pointer to value, i.e. <code>value_type*</code> const_pointer Type of pointer to const value, i.e. <code>const value_type*</code> reference Type of reference to value, i.e. <code>value_type&amp;</code> const_reference Type of reference to const value, i.e. <code>const value_type&amp;</code> size_type Unsigned integer type of size of <code>btree_map</code>, i.e. <code>std::size_t</code> difference_type Signed integer type of the difference of two iterators iterator Type of iterator const_iterator Type of const iterator reverse_iterator Type of reverse iterator const_reverse_iterator Type of const reverse iterator"},{"location":"reference/btree_map/#member-function","title":"Member function","text":""},{"location":"reference/btree_map/#constructor","title":"Constructor","text":"<pre><code>// (1)\nbtree_map();\n// (2)\nbtree_map(const btree_map&amp;);\n// (3)\nbtree_map(btree_map&amp;&amp;);\n\n// (4)\nexplicit btree_map(const key_compare&amp; comp, const allocator_type&amp; alloc = allocator_type());\n// (5)\nexplicit btree_map(const allocator_type&amp; alloc);\n\n// (6)\ntemplate &lt;class InputIterator&gt;\nbtree_map(\n    InputIterator         b,\n    InputIterator         e,\n    const key_compare&amp;    comp  = key_compare(),\n    const allocator_type&amp; alloc = allocator_type()\n);\n// (7)\ntemplate &lt;class InputIterator&gt;\nbtree_map(InputIterator b, InputIterator e, const allocator_type&amp; alloc);\n\n// (8)\nbtree_map(const btree_map&amp; x, const allocator_type&amp; alloc);\n// (9)\nbtree_map(btree_map&amp;&amp; x, const allocator_type&amp; alloc);\n\n// (10)\nbtree_map(\n    std::initializer_list&lt;value_type&gt; init,\n    const key_compare&amp;                comp  = key_compare{},\n    const allocator_type&amp;             alloc = allocator_type{}\n);\n// (11)\nbtree_map(std::initializer_list&lt;value_type&gt; init, const allocator_type&amp; alloc);\n\n// (12)\nbtree_map&amp; operator=(const btree_map&amp; x);\n// (13)\nbtree_map&amp; operator=(btree_map&amp;&amp;) = default;\n</code></pre> <ol> <li>Constructs an empty <code>btree_map</code>.</li> <li>Copy constructor. The allocator is copied by <code>std::allocator_traits::select_on_container_copy_construction</code>.</li> <li>Move constructor. The allocator is copied by <code>operator=</code>.</li> <li>Constructs an empty <code>btree_map</code> with <code>comp</code> and <code>alloc</code>.</li> <li>Constructs an empty <code>btree_map</code> with <code>alloc</code>.</li> <li>Constructs a <code>btree_map</code> with <code>comp</code> and <code>alloc</code> by inserting values from <code>b</code> to <code>e</code> (<code>e</code> isn't included).</li> <li>Constructs a <code>btree_map</code> with <code>alloc</code> by inserting values from <code>b</code> to <code>e</code> (<code>e</code> isn't included).</li> <li>Constructs a copy of <code>x</code> with <code>alloc</code>.</li> <li>Constructs a <code>btree_map</code> to which <code>x</code> is moved with <code>alloc</code>.</li> <li>Constructs a <code>btree_map</code> with <code>comp</code> and <code>alloc</code> from an initializer list.</li> <li>Constructs a <code>btree_map</code> with <code>alloc</code> from an initializer list.</li> <li>Assigns a copy of <code>x</code> and return <code>*this</code>. If <code>x</code> is <code>*this</code>, does nothing.</li> <li>Default move assignment operator.</li> </ol>"},{"location":"reference/btree_map/#iterator","title":"Iterator","text":"<pre><code>// (1)\niterator               begin();\n// (2)\nconst_iterator         begin() const;\n// (3)\nconst_iterator         cbegin() const;\n\n// (4)\niterator               end();\n// (5)\nconst_iterator         end() const;\n// (6)\nconst_iterator         cend() const;\n\n// (7)\nreverse_iterator       rbegin();\n// (8)\nconst_reverse_iterator rbegin() const;\n// (9)\nconst_reverse_iterator crbegin() const;\n\n// (10)\nreverse_iterator       rend();\n// (11)\nconst_reverse_iterator rend() const;\n// (12)\nconst_reverse_iterator crend() const;\n</code></pre> <ol> <li>Return the iterator pointing to the first value of <code>*this</code>.</li> <li>The <code>const</code> version of 1.</li> <li>Return the const iterator pointing to the first value of <code>*this</code>.</li> <li>Return the iterator pointing to the next address of the last value of <code>*this</code>.</li> <li>The <code>const</code> version of 4.</li> <li>Return the const iterator pointing to the next address of the last value of <code>*this</code>.</li> <li>Return the reverse iterator pointing to the last value of <code>*this</code>.</li> <li>The <code>const</code> version of 7.</li> <li>Return the const reverse iterator pointing to the last value of <code>*this</code>.</li> <li>Return the reverse iterator pointing to the previous address of the first value of <code>*this</code>.</li> <li>The <code>const</code> version of 10.</li> <li>Return the const reverse iterator pointing to the previous address of the first value of <code>*this</code>.</li> </ol>"},{"location":"reference/btree_map/#modifiers","title":"Modifiers","text":"<pre><code>// (1)\nvoid clear();\n// (2)\nvoid swap(btree_map&amp; x);\n// (3)\nvoid merge(btree_map&amp; x);\n// (4)\nvoid merge(btree_map&amp;&amp; x);\n// (5)\nmapped_type&amp; operator[](const key_type&amp; key);\n// (6)\nmapped_type&amp; operator[](key_type&amp;&amp; key);\n// (7)\nmapped_type&amp; at(const key_type&amp; key);\n// (8)\nconst mapped_type&amp; at(const key_type&amp; key) const;\n</code></pre> <ol> <li>Clear <code>*this</code>, i.e., delete all values in <code>*this</code>.</li> <li>Swap <code>*this</code> for <code>x</code>.</li> <li>Merge another <code>btree_map</code>. The duplicated values will not be merged to <code>*this</code>.</li> <li>Same as 3. This function is provided to receive an rvalue <code>btree_map</code>, so no rvalue-specific optimization is done.</li> <li>Return the reference of the value mapped to <code>key</code>. If <code>key</code> doesn't exist, insert <code>key</code> and default constructed <code>mapped_value</code>.</li> <li>The rvalue version of 5.</li> <li>Return the reference of the value mapped to <code>key</code>. If <code>key</code> doesn't exist, throw <code>std::out_of_range</code>.</li> <li>The const version of 7.</li> </ol>"},{"location":"reference/btree_map/#insert","title":"<code>insert</code>","text":"<pre><code>// (1)\nstd::pair&lt;iterator, bool&gt; insert(const value_type&amp; x);\n// (2)\nstd::pair&lt;iterator, bool&gt; insert(value_type&amp;&amp; x);\n\n// (3)\niterator insert(iterator hint, const value_type&amp; x);\n// (4)\niterator insert(iterator hint, value_type&amp;&amp; x);\n\n// (5)\ntemplate &lt;typename InputIterator&gt;\nvoid insert(InputIterator b, InputIterator e);\n\n// (6)\nvoid insert(std::initializer_list&lt;value_type&gt; list);\n</code></pre> <ol> <li>If there is <code>x</code> in <code>*this</code>, returns an iterator pointing to <code>x</code> in <code>*this</code> and <code>false</code>. Otherwise, inserts <code>x</code> and returns an iterator pointing to <code>x</code> in <code>*this</code> and <code>true</code>.</li> <li>The rvalue version of 1.</li> <li>Does 1 with hint. If the value is placed immediately before <code>hint</code> in the tree, the insertion will take amortized constant time. If not, the insertion will take amortized logarithmic time as if a call to <code>insert(x)</code> were made.</li> <li>The rvalue version of 3.</li> <li>Does 1 for each value from <code>b</code> to <code>e</code> (<code>e</code> isn't included).</li> <li>Does 1 for each value of <code>list</code>.</li> </ol>"},{"location":"reference/btree_map/#erase","title":"<code>erase</code>","text":"<pre><code>size_type erase(const key_type&amp; key);\niterator  erase(const iterator&amp; iter);\nvoid      erase(const iterator&amp; b, const iterator&amp; e);\n</code></pre> <ol> <li>Erases the specified key from <code>*this</code> and returns</li> <li>Erases the specified iterator from <code>*this</code>. The iterator must be valid (i.e. not equal to end()). Return an iterator pointing to the node after the one that was erased (or end() if none exists).</li> <li>Erases a range from <code>b</code> to <code>e</code> (<code>e</code> isn't included) and return the number of erased keys.</li> </ol>"},{"location":"reference/btree_map/#lookup","title":"Lookup","text":"<pre><code>// (1)\niterator       lower_bound(const key_type&amp; key);\n// (2)\nconst_iterator lower_bound(const key_type&amp; key) const;\n\n// (3)\niterator       upper_bound(const key_type&amp; key);\n// (4)\nconst_iterator upper_bound(const key_type&amp; key) const;\n\n// (5)\nstd::pair&lt;iterator, iterator&gt; equal_range(const key_type&amp; key);\n// (6)\nstd::pair&lt;const_iterator, const_iterator&gt; equal_range(const key_type&amp; key) const;\n\n// (7)\niterator       find(const key_type&amp; key);\n// (8)\nconst_iterator find(const key_type&amp; key) const;\n\n// (9)\nsize_type      count(const key_type&amp; key) const;\n\n// (10)\nbool           contains(const key_type&amp; key) const;\n</code></pre> <ol> <li>If <code>*this</code> is empty or <code>key</code> isn't found, returns <code>end()</code>. Otherwise, returns an iterator which points to the minimum value in all values which are not less than <code>key</code>.</li> <li>The <code>const</code> version of 1.</li> <li>If <code>*this</code> is empty or <code>key</code> isn't found, returns <code>end()</code>. Otherwise, returns an iterator which points to the minimum value in all values which are greater than <code>key</code>.</li> <li>The <code>const</code> version of 3.</li> <li>If <code>*this</code> is empty or <code>key</code> isn't found, returns <code>std::make_pair(end(), end())</code>. Otherwise, returns a pair of the iterators which point to the fist value in all values which are equal to <code>key</code> and the value next to the last value in them in order.</li> <li>The <code>const</code> version of 5.</li> <li>If <code>*this</code> is empty or <code>key</code> isn't found, returns <code>end()</code>. Otherwise, returns an iterator which points to the fist value in all values which are equal to <code>key</code>.</li> <li>The <code>const</code> version of 7.</li> <li>If <code>*this</code> is empty or <code>key</code> isn't found, returns <code>0</code>. Otherwise, returns <code>1</code>.</li> <li>If <code>*this</code> is empty or <code>key</code> isn't found, returns <code>false</code>. Otherwise, returns <code>true</code>.</li> </ol>"},{"location":"reference/btree_map/#capacity","title":"Capacity","text":"<pre><code>// (1)\nsize_type size() const;\n// (2)\nsize_type max_size() const;\n// (3)\nbool      empty() const;\n</code></pre> 1. Returns the number of values. 1. Returns the max number of values. 1. Returns a bool whether <code>*this</code> is empty or not."},{"location":"reference/btree_map/#observers","title":"Observers","text":"<pre><code>key_compare key_comp() const noexcept;\n</code></pre> Returns the <code>key_compare</code> object used by <code>*this</code>."},{"location":"reference/btree_map/#non-stl","title":"non-STL","text":"<p>[WARNING] The following functions may be suddenly deleted.</p> <pre><code>// (1)\nsize_type height() const;\n// (2)\nsize_type internal_nodes() const;\n// (3)\nsize_type leaf_nodes() const;\n// (4)\nsize_type nodes() const;\n// (5)\nsize_type bytes_used() const;\n// (6)\ndouble    average_bytes_per_value() const;\n// (7)\ndouble    fullness() const;\n// (8)\ndouble    overhead() const;\n// (9)\nvoid      dump(std::ostream&amp; os) const;\n// (10)\nvoid      verify() const;\n// (11)\nstatic constexpr std::size_t sizeof_leaf_node();\n// (12)\nstatic constexpr std::size_t sizeof_internal_node();\n</code></pre> <ol> <li>Returns the hight of <code>*this</code>.</li> <li>Returns the number of internal nodes.</li> <li>Returns the number of leaf nodes.</li> <li>Returns the total of internal nodes and leaf nodes.</li> <li>Returns the total of bytes used by <code>*this</code>.</li> <li>Returns the average bytes per value.</li> <li>Returns the fullness of <code>*this</code>, which is computed as the number of elements in <code>*this</code> divided by the maximum number of elements a tree with the current number of nodes could hold. A value of 1 indicates perfect space utilization. Smaller values indicate space wastage.</li> <li>Returns the overhead of the btree structure in bytes per node, which is computed as the total number of bytes used by <code>*this</code> minus the number of bytes used for storing elements divided by the number of values.</li> <li>Dumps the btree to the specified ostream. Requires that <code>operator&lt;&lt;</code> is defined for value.</li> <li>Verifies the structure of <code>*this</code>.</li> <li>Returns the size of a leaf node.</li> <li>Returns the size of a internal node.</li> </ol>"},{"location":"reference/btree_map/#non-member-function","title":"Non-member function","text":""},{"location":"reference/btree_map/#swap","title":"Swap","text":"<pre><code>template &lt;typename K, typename C, typename A, std::size_t N&gt;\nvoid swap(btree_map&lt;K, C, A, N&gt;&amp; x, btree_map&lt;K, C, A, N&gt;&amp; y);\n</code></pre> <p>Swap <code>x</code> for <code>y</code> using <code>std::swap</code> to swap each member variable of <code>x</code> for that of <code>y</code>.</p>"},{"location":"reference/btree_multimap/","title":"btree_multimap","text":""},{"location":"reference/btree_multimap/#btree_multimap","title":"btree_multimap","text":"<p>In <code>platanus/btree_map.hpp</code>,</p> <pre><code>namespace platanus {\ntemplate &lt;\n    typename Key,\n    typename Value,\n    typename Compare           = std::ranges::less,\n    typename Alloc             = std::allocator&lt;Key&gt;,\n    std::size_t MaxNumOfValues = 512&gt;\nclass btree_multimap;\n}\n</code></pre>"},{"location":"reference/btree_multimap/#template-parameters","title":"Template parameters","text":"Parameter Meaning <code>Key</code> Type of a key <code>Value</code> Type of a value <code>Compare</code> Type of a func obj comparing two key in a weak order. If Key doesn't implement three-way comparison operator, the default type does using <code>&lt;</code> and <code>=</code>. <code>Alloc</code> Type of an allocator. The default is <code>std::allocator&lt;Key&gt;</code>. <code>MaxNumOfValues</code> The max number of values per node. The default is 64."},{"location":"reference/btree_multimap/#member-types","title":"Member types","text":"Type Meaning key_type Type of key, i.e. <code>Key</code> value_type Type of value, i.e. <code>std::pair&lt;const Key, Value&gt;</code> mapped_type Type of mapped value, i.e. <code>Value</code> key_compare Type of comparer of key, i.e. <code>Compare</code> allocator_type Type of allocator, i.e. <code>Alloc</code> pointer Type of pointer to value, i.e. <code>value_type*</code> const_pointer Type of pointer to const value, i.e. <code>const value_type*</code> reference Type of reference to value, i.e. <code>value_type&amp;</code> const_reference Type of reference to const value, i.e. <code>const value_type&amp;</code> size_type Unsigned integer type of size of <code>btree_multimap</code>, i.e. <code>std::size_t</code> difference_type Signed integer type of the difference of two iterators iterator Type of iterator const_iterator Type of const iterator reverse_iterator Type of reverse iterator const_reverse_iterator Type of const reverse iterator"},{"location":"reference/btree_multimap/#member-function","title":"Member function","text":""},{"location":"reference/btree_multimap/#constructor","title":"Constructor","text":"<pre><code>// (1)\nbtree_multimap();\n// (2)\nbtree_multimap(const btree_multimap&amp;);\n// (3)\nbtree_multimap(btree_multimap&amp;&amp;);\n\n// (4)\nexplicit btree_multimap(const key_compare&amp; comp, const allocator_type&amp; alloc = allocator_type());\n// (5)\nexplicit btree_multimap(const allocator_type&amp; alloc);\n\n// (6)\ntemplate &lt;class InputIterator&gt;\nbtree_multimap(\n    InputIterator         b,\n    InputIterator         e,\n    const key_compare&amp;    comp  = key_compare(),\n    const allocator_type&amp; alloc = allocator_type()\n);\n// (7)\ntemplate &lt;class InputIterator&gt;\nbtree_multimap(InputIterator b, InputIterator e, const allocator_type&amp; alloc);\n\n// (8)\nbtree_multimap(const btree_multimap&amp; x, const allocator_type&amp; alloc);\n// (9)\nbtree_multimap(btree_multimap&amp;&amp; x, const allocator_type&amp; alloc);\n\n// (10)\nbtree_multimap(\n    std::initializer_list&lt;value_type&gt; init,\n    const key_compare&amp;                comp  = key_compare{},\n    const allocator_type&amp;             alloc = allocator_type{}\n);\n// (11)\nbtree_multimap(std::initializer_list&lt;value_type&gt; init, const allocator_type&amp; alloc);\n\n// (12)\nbtree_multimap&amp; operator=(const btree_multimap&amp; x);\n// (13)\nbtree_multimap&amp; operator=(btree_multimap&amp;&amp;) = default;\n</code></pre> <ol> <li>Constructs an empty <code>btree_multimap</code>.</li> <li>Copy constructor. The allocator is copied by <code>std::allocator_traits::select_on_container_copy_construction</code>.</li> <li>Move constructor. The allocator is copied by <code>operator=</code>.</li> <li>Constructs an empty <code>btree_multimap</code> with <code>comp</code> and <code>alloc</code>.</li> <li>Constructs an empty <code>btree_multimap</code> with <code>alloc</code>.</li> <li>Constructs a <code>btree_multimap</code> with <code>comp</code> and <code>alloc</code> by inserting values from <code>b</code> to <code>e</code> (<code>e</code> isn't included).</li> <li>Constructs a <code>btree_multimap</code> with <code>alloc</code> by inserting values from <code>b</code> to <code>e</code> (<code>e</code> isn't included).</li> <li>Constructs a copy of <code>x</code> with <code>alloc</code>.</li> <li>Constructs a <code>btree_multimap</code> to which <code>x</code> is moved with <code>alloc</code>.</li> <li>Constructs a <code>btree_multimap</code> with <code>comp</code> and <code>alloc</code> from an initializer list.</li> <li>Constructs a <code>btree_multimap</code> with <code>alloc</code> from an initializer list.</li> <li>Assigns a copy of <code>x</code> and return <code>*this</code>. If <code>x</code> is <code>*this</code>, does nothing.</li> <li>Default move assignment operator.</li> </ol>"},{"location":"reference/btree_multimap/#iterator","title":"Iterator","text":"<pre><code>// (1)\niterator               begin();\n// (2)\nconst_iterator         begin() const;\n// (3)\nconst_iterator         cbegin() const;\n\n// (4)\niterator               end();\n// (5)\nconst_iterator         end() const;\n// (6)\nconst_iterator         cend() const;\n\n// (7)\nreverse_iterator       rbegin();\n// (8)\nconst_reverse_iterator rbegin() const;\n// (9)\nconst_reverse_iterator crbegin() const;\n\n// (10)\nreverse_iterator       rend();\n// (11)\nconst_reverse_iterator rend() const;\n// (12)\nconst_reverse_iterator crend() const;\n</code></pre> <ol> <li>Return the iterator pointing to the first value of <code>*this</code>.</li> <li>The <code>const</code> version of 1.</li> <li>Return the const iterator pointing to the first value of <code>*this</code>.</li> <li>Return the iterator pointing to the next address of the last value of <code>*this</code>.</li> <li>The <code>const</code> version of 4.</li> <li>Return the const iterator pointing to the next address of the last value of <code>*this</code>.</li> <li>Return the reverse iterator pointing to the last value of <code>*this</code>.</li> <li>The <code>const</code> version of 7.</li> <li>Return the const reverse iterator pointing to the last value of <code>*this</code>.</li> <li>Return the reverse iterator pointing to the previous address of the first value of <code>*this</code>.</li> <li>The <code>const</code> version of 10.</li> <li>Return the const reverse iterator pointing to the previous address of the first value of <code>*this</code>.</li> </ol>"},{"location":"reference/btree_multimap/#modifiers","title":"Modifiers","text":"<pre><code>// (1)\nvoid clear();\n// (2)\nvoid swap(btree_multimap&amp; x);\n// (3)\nvoid merge(btree_multimap&amp; x);\n// (4)\nvoid merge(btree_multimap&amp;&amp; x);\n</code></pre> <ol> <li>Clear <code>*this</code>, i.e., delete all values in <code>*this</code>.</li> <li>Swap <code>*this</code> for <code>x</code>.</li> <li>Merge another <code>btree_multimap</code>. The duplicated values will not be merged to <code>*this</code>.</li> <li>Same as 3. This function is provided to receive an rvalue <code>btree_multimap</code>, so no rvalue-specific optimization is done.</li> </ol>"},{"location":"reference/btree_multimap/#insert","title":"<code>insert</code>","text":"<pre><code>// (1)\nstd::pair&lt;iterator, bool&gt; insert(const value_type&amp; x);\n// (2)\nstd::pair&lt;iterator, bool&gt; insert(value_type&amp;&amp; x);\n\n// (3)\niterator insert(iterator hint, const value_type&amp; x);\n// (4)\niterator insert(iterator hint, value_type&amp;&amp; x);\n\n// (5)\ntemplate &lt;typename InputIterator&gt;\nvoid insert(InputIterator b, InputIterator e);\n\n// (6)\nvoid insert(std::initializer_list&lt;value_type&gt; list);\n</code></pre> <ol> <li>If there is <code>x</code> in <code>*this</code>, returns an iterator pointing to <code>x</code> in <code>*this</code> and <code>false</code>. Otherwise, inserts <code>x</code> and returns an iterator pointing to <code>x</code> in <code>*this</code> and <code>true</code>.</li> <li>The rvalue version of 1.</li> <li>Does 1 with hint. If the value is placed immediately before <code>hint</code> in the tree, the insertion will take amortized constant time. If not, the insertion will take amortized logarithmic time as if a call to <code>insert(x)</code> were made.</li> <li>The rvalue version of 3.</li> <li>Does 1 for each value from <code>b</code> to <code>e</code> (<code>e</code> isn't included).</li> <li>Does 1 for each value of <code>list</code>.</li> </ol>"},{"location":"reference/btree_multimap/#erase","title":"<code>erase</code>","text":"<pre><code>size_type erase(const key_type&amp; key);\niterator  erase(const iterator&amp; iter);\nvoid      erase(const iterator&amp; b, const iterator&amp; e);\n</code></pre> <ol> <li>Erases the specified key from <code>*this</code> and returns</li> <li>Erases the specified iterator from <code>*this</code>. The iterator must be valid (i.e. not equal to end()). Return an iterator pointing to the node after the one that was erased (or end() if none exists).</li> <li>Erases a range from <code>b</code> to <code>e</code> (<code>e</code> isn't included) and return the number of erased keys.</li> </ol>"},{"location":"reference/btree_multimap/#lookup","title":"Lookup","text":"<pre><code>// (1)\niterator       lower_bound(const key_type&amp; key);\n// (2)\nconst_iterator lower_bound(const key_type&amp; key) const;\n\n// (3)\niterator       upper_bound(const key_type&amp; key);\n// (4)\nconst_iterator upper_bound(const key_type&amp; key) const;\n\n// (5)\nstd::pair&lt;iterator, iterator&gt; equal_range(const key_type&amp; key);\n// (6)\nstd::pair&lt;const_iterator, const_iterator&gt; equal_range(const key_type&amp; key) const;\n\n// (7)\niterator       find(const key_type&amp; key);\n// (8)\nconst_iterator find(const key_type&amp; key) const;\n\n// (9)\nsize_type      count(const key_type&amp; key) const;\n\n// (10)\nbool           contains(const key_type&amp; key) const;\n</code></pre> <ol> <li>If <code>*this</code> is empty or <code>key</code> isn't found, returns <code>end()</code>. Otherwise, returns an iterator which points to the minimum value in all values which are not less than <code>key</code>.</li> <li>The <code>const</code> version of 1.</li> <li>If <code>*this</code> is empty or <code>key</code> isn't found, returns <code>end()</code>. Otherwise, returns an iterator which points to the minimum value in all values which are greater than <code>key</code>.</li> <li>The <code>const</code> version of 3.</li> <li>If <code>*this</code> is empty or <code>key</code> isn't found, returns <code>end()</code>. Otherwise, returns a pair of the iterators which point to the fist value in all values which are equal to <code>key</code> and the value next to the last value in them in order.</li> <li>The <code>const</code> version of 5.</li> <li>If <code>*this</code> is empty or <code>key</code> isn't found, returns <code>end()</code>. Otherwise, returns an iterator which points to the fist value in all values which are equal to <code>key</code>.</li> <li>The <code>const</code> version of 7.</li> <li>If <code>*this</code> is empty or <code>key</code> isn't found, returns <code>0</code>. Otherwise, returns <code>1</code>.</li> <li>If <code>*this</code> is empty or <code>key</code> isn't found, returns <code>false</code>. Otherwise, returns <code>true</code>.</li> </ol>"},{"location":"reference/btree_multimap/#capacity","title":"Capacity","text":"<pre><code>// (1)\nsize_type size() const;\n// (2)\nsize_type max_size() const;\n// (3)\nbool      empty() const;\n</code></pre> <ol> <li>Returns the number of values.</li> <li>Returns the max number of values.</li> <li>Returns a bool whether <code>*this</code> is empty or not.</li> </ol>"},{"location":"reference/btree_multimap/#observers","title":"Observers","text":"<pre><code>key_compare key_comp() const noexcept;\n</code></pre> <p>Returns the <code>key_compare</code> object used by <code>*this</code>.</p>"},{"location":"reference/btree_multimap/#non-stl","title":"non-STL","text":"<p>[WARNING] The following functions may be suddenly deleted.</p> <pre><code>// (1)\nsize_type height() const;\n// (2)\nsize_type internal_nodes() const;\n// (3)\nsize_type leaf_nodes() const;\n// (4)\nsize_type nodes() const;\n// (5)\nsize_type bytes_used() const;\n// (6)\ndouble    average_bytes_per_value() const;\n// (7)\ndouble    fullness() const;\n// (8)\ndouble    overhead() const;\n// (9)\nvoid      dump(std::ostream&amp; os) const;\n// (10)\nvoid      verify() const;\n// (11)\nstatic constexpr std::size_t sizeof_leaf_node();\n// (12)\nstatic constexpr std::size_t sizeof_internal_node();\n</code></pre> <ol> <li>Returns the hight of <code>*this</code>.</li> <li>Returns the number of internal nodes.</li> <li>Returns the number of leaf nodes.</li> <li>Returns the total of internal nodes and leaf nodes.</li> <li>Returns the total of bytes used by <code>*this</code>.</li> <li>Returns the average bytes per value.</li> <li>Returns the fullness of <code>*this</code>, which is computed as the number of elements in <code>*this</code> divided by the maximum number of elements a tree with the current number of nodes could hold. A value of 1 indicates perfect space utilization. Smaller values indicate space wastage.</li> <li>Returns the overhead of the btree structure in bytes per node, which is computed as the total number of bytes used by <code>*this</code> minus the number of bytes used for storing elements divided by the number of values.</li> <li>Dumps the btree to the specified ostream. Requires that <code>operator&lt;&lt;</code> is defined for value.</li> <li>Verifies the structure of <code>*this</code>.</li> <li>Returns the size of a leaf node.</li> <li>Returns the size of a internal node.</li> </ol>"},{"location":"reference/btree_multimap/#non-member-function","title":"Non-member function","text":""},{"location":"reference/btree_multimap/#swap","title":"Swap","text":"<pre><code>template &lt;typename K, typename C, typename A, std::size_t N&gt;\nvoid swap(btree_multimap&lt;K, C, A, N&gt;&amp; x, btree_multimap&lt;K, C, A, N&gt;&amp; y);\n</code></pre> <p>Swap <code>x</code> for <code>y</code> using <code>std::swap</code> to swap each member variable of <code>x</code> for that of <code>y</code>.</p>"},{"location":"reference/btree_multiset/","title":"btree_multiset","text":""},{"location":"reference/btree_multiset/#btree_multiset","title":"btree_multiset","text":"<p>In <code>platanus/btree_set.hpp</code>,</p> <pre><code>namespace platanus {\ntemplate &lt;\n    typename Key,\n    typename Compare           = std::ranges::less,\n    typename Alloc             = std::allocator&lt;Key&gt;,\n    std::size_t MaxNumOfValues = 512&gt;\nclass btree_multiset;\n}\n</code></pre>"},{"location":"reference/btree_multiset/#template-parameters","title":"Template parameters","text":"Parameter Meaning <code>Key</code> Type of a key <code>Compare</code> Type of a func obj comparing two key in a weak order. If Key doesn't implement three-way comparison operator, the default type does using <code>&lt;</code> and <code>=</code>. <code>Alloc</code> Type of an allocator. The default is <code>std::allocator&lt;Key&gt;</code>. <code>MaxNumOfValues</code> The max number of values per node. The default is 64."},{"location":"reference/btree_multiset/#member-types","title":"Member types","text":"Type Meaning key_type Type of key, i.e. <code>Key</code> value_type Type of value, i.e. <code>Key</code> key_compare Type of comparer of key, i.e. <code>Compare</code> value_compare Type of comparer of value, i.e. <code>Compare</code> allocator_type Type of allocator, i.e. <code>Alloc</code> pointer Type of pointer to value, i.e. <code>Key*</code> const_pointer Type of pointer to const value, i.e. <code>const Key*</code> reference Type of reference to value, i.e. <code>Key&amp;</code> const_reference Type of reference to const value, i.e. <code>const Key&amp;</code> size_type Unsigned integer type of size of <code>btree_multiset</code>, i.e. <code>std::size_t</code> difference_type Signed integer type of the difference of two iterators iterator Type of iterator const_iterator Type of const iterator reverse_iterator Type of reverse iterator const_reverse_iterator Type of const reverse iterator"},{"location":"reference/btree_multiset/#member-function","title":"Member function","text":""},{"location":"reference/btree_multiset/#constructor","title":"Constructor","text":"<pre><code>// (1)\nbtree_multiset();\n// (2)\nbtree_multiset(const btree_multiset&amp;);\n// (3)\nbtree_multiset(btree_multiset&amp;&amp;);\n\n// (4)\nexplicit btree_multiset(const key_compare&amp; comp, const allocator_type&amp; alloc = allocator_type());\n// (5)\nexplicit btree_multiset(const allocator_type&amp; alloc);\n\n// (6)\ntemplate &lt;class InputIterator&gt;\nbtree_multiset(\n    InputIterator         b,\n    InputIterator         e,\n    const key_compare&amp;    comp  = key_compare(),\n    const allocator_type&amp; alloc = allocator_type()\n);\n// (7)\ntemplate &lt;class InputIterator&gt;\nbtree_multiset(InputIterator b, InputIterator e, const allocator_type&amp; alloc);\n\n// (8)\nbtree_multiset(const btree_multiset&amp; x, const allocator_type&amp; alloc);\n// (9)\nbtree_multiset(btree_multiset&amp;&amp; x, const allocator_type&amp; alloc);\n\n// (10)\nbtree_multiset(\n    std::initializer_list&lt;value_type&gt; init,\n    const key_compare&amp;                comp  = key_compare{},\n    const allocator_type&amp;             alloc = allocator_type{}\n);\n// (11)\nbtree_multiset(std::initializer_list&lt;value_type&gt; init, const allocator_type&amp; alloc);\n\n// (12)\nbtree_multiset&amp; operator=(const btree_multiset&amp; x);\n// (13)\nbtree_multiset&amp; operator=(btree_multiset&amp;&amp;) = default;\n</code></pre> <ol> <li>Constructs an empty <code>btree_multiset</code>.</li> <li>Copy constructor. The allocator is copied by <code>std::allocator_traits::select_on_container_copy_construction</code>.</li> <li>Move constructor. The allocator is copied by <code>operator=</code>.</li> <li>Constructs an empty <code>btree_multiset</code> with <code>comp</code> and <code>alloc</code>.</li> <li>Constructs an empty <code>btree_multiset</code> with <code>alloc</code>.</li> <li>Constructs a <code>btree_multiset</code> with <code>comp</code> and <code>alloc</code> by inserting values from <code>b</code> to <code>e</code> (<code>e</code> isn't included).</li> <li>Constructs a <code>btree_multiset</code> with <code>alloc</code> by inserting values from <code>b</code> to <code>e</code> (<code>e</code> isn't included).</li> <li>Constructs a copy of <code>x</code> with <code>alloc</code>.</li> <li>Constructs a <code>btree_multiset</code> to which <code>x</code> is moved with <code>alloc</code>.</li> <li>Constructs a <code>btree_multiset</code> with <code>comp</code> and <code>alloc</code> from an initializer list.</li> <li>Constructs a <code>btree_multiset</code> with <code>alloc</code> from an initializer list.</li> <li>Assigns a copy of <code>x</code> and return <code>*this</code>. If <code>x</code> is <code>*this</code>, does nothing.</li> <li>Default move assignment operator.</li> </ol>"},{"location":"reference/btree_multiset/#iterator","title":"Iterator","text":"<pre><code>// (1)\niterator               begin();\n// (2)\nconst_iterator         begin() const;\n// (3)\nconst_iterator         cbegin() const;\n\n// (4)\niterator               end();\n// (5)\nconst_iterator         end() const;\n// (6)\nconst_iterator         cend() const;\n\n// (7)\nreverse_iterator       rbegin();\n// (8)\nconst_reverse_iterator rbegin() const;\n// (9)\nconst_reverse_iterator crbegin() const;\n\n// (10)\nreverse_iterator       rend();\n// (11)\nconst_reverse_iterator rend() const;\n// (12)\nconst_reverse_iterator crend() const;\n</code></pre> <ol> <li>Return the iterator pointing to the first value of <code>*this</code>.</li> <li>The <code>const</code> version of 1.</li> <li>Return the const iterator pointing to the first value of <code>*this</code>.</li> <li>Return the iterator pointing to the next address of the last value of <code>*this</code>.</li> <li>The <code>const</code> version of 4.</li> <li>Return the const iterator pointing to the next address of the last value of <code>*this</code>.</li> <li>Return the reverse iterator pointing to the last value of <code>*this</code>.</li> <li>The <code>const</code> version of 7.</li> <li>Return the const reverse iterator pointing to the last value of <code>*this</code>.</li> <li>Return the reverse iterator pointing to the previous address of the first value of <code>*this</code>.</li> <li>The <code>const</code> version of 10.</li> <li>Return the const reverse iterator pointing to the previous address of the first value of <code>*this</code>.</li> </ol>"},{"location":"reference/btree_multiset/#modifiers","title":"Modifiers","text":"<pre><code>// (1)\nvoid clear();\n// (2)\nvoid swap(btree_multiset&amp; x);\n// (3)\nvoid merge(btree_multiset&amp; x);\n// (4)\nvoid merge(btree_multiset&amp;&amp; x);\n</code></pre> <ol> <li>Clear <code>*this</code>, i.e., delete all values in <code>*this</code>.</li> <li>Swap <code>*this</code> for <code>x</code>.</li> <li>Merge another <code>btree_multiset</code>. The duplicated values will not be merged to <code>*this</code>.</li> <li>Same as 3. This function is provided to receive an rvalue <code>btree_multiset</code>, so no rvalue-specific optimization is done.</li> </ol>"},{"location":"reference/btree_multiset/#insert","title":"<code>insert</code>","text":"<pre><code>// (1)\nstd::pair&lt;iterator, bool&gt; insert(const value_type&amp; x);\n// (2)\nstd::pair&lt;iterator, bool&gt; insert(value_type&amp;&amp; x);\n\n// (3)\niterator insert(iterator hint, const value_type&amp; x);\n// (4)\niterator insert(iterator hint, value_type&amp;&amp; x);\n\n// (5)\ntemplate &lt;typename InputIterator&gt;\nvoid insert(InputIterator b, InputIterator e);\n\n// (6)\nvoid insert(std::initializer_list&lt;value_type&gt; list);\n</code></pre> <ol> <li>If there is <code>x</code> in <code>*this</code>, returns an iterator pointing to <code>x</code> in <code>*this</code> and <code>false</code>. Otherwise, inserts <code>x</code> and returns an iterator pointing to <code>x</code> in <code>*this</code> and <code>true</code>.</li> <li>The rvalue version of 1.</li> <li>Does 1 with hint. If the value is placed immediately before <code>hint</code> in the tree, the insertion will take amortized constant time. If not, the insertion will take amortized logarithmic time as if a call to <code>insert(x)</code> were made.</li> <li>The rvalue version of 3.</li> <li>Does 1 for each value from <code>b</code> to <code>e</code> (<code>e</code> isn't included).</li> <li>Does 1 for each value of <code>list</code>.</li> </ol>"},{"location":"reference/btree_multiset/#erase","title":"<code>erase</code>","text":"<pre><code>size_type erase(const key_type&amp; key);\niterator  erase(const iterator&amp; iter);\nvoid      erase(const iterator&amp; b, const iterator&amp; e);\n</code></pre> <ol> <li>Erases the specified key from <code>*this</code> and returns</li> <li>Erases the specified iterator from <code>*this</code>. The iterator must be valid (i.e. not equal to end()). Return an iterator pointing to the node after the one that was erased (or end() if none exists).</li> <li>Erases a range from <code>b</code> to <code>e</code> (<code>e</code> isn't included) and return the number of erased keys.</li> </ol>"},{"location":"reference/btree_multiset/#lookup","title":"Lookup","text":"<pre><code>// (1)\niterator       lower_bound(const key_type&amp; key);\n// (2)\nconst_iterator lower_bound(const key_type&amp; key) const;\n\n// (3)\niterator       upper_bound(const key_type&amp; key);\n// (4)\nconst_iterator upper_bound(const key_type&amp; key) const;\n\n// (5)\nstd::pair&lt;iterator, iterator&gt; equal_range(const key_type&amp; key);\n// (6)\nstd::pair&lt;const_iterator, const_iterator&gt; equal_range(const key_type&amp; key) const;\n\n// (7)\niterator       find(const key_type&amp; key);\n// (8)\nconst_iterator find(const key_type&amp; key) const;\n\n// (9)\nsize_type      count(const key_type&amp; key) const;\n\n// (10)\nbool           contains(const key_type&amp; key) const;\n</code></pre> <ol> <li>If <code>*this</code> is empty or <code>key</code> isn't found, returns <code>end()</code>. Otherwise, returns an iterator which points to the first value in all values which are not less than <code>key</code>.</li> <li>The <code>const</code> version of 1.</li> <li>If <code>*this</code> is empty or <code>key</code> isn't found, returns <code>end()</code>. Otherwise, returns an iterator which points to the first value in all values which are greater than <code>key</code>.</li> <li>The <code>const</code> version of 3.</li> <li>If <code>*this</code> is empty or <code>key</code> isn't found, returns <code>end()</code>. Otherwise, returns a pair of the iterators which point to the fist value in all values which are equal to <code>key</code> and the value next to the last value in them in order.</li> <li>The <code>const</code> version of 5.</li> <li>If <code>*this</code> is empty or <code>key</code> isn't found, returns <code>end()</code>. Otherwise, returns an iterator which points to the fist value in all values which are equal to <code>key</code>.</li> <li>The <code>const</code> version of 7.</li> <li>If <code>*this</code> is empty or <code>key</code> isn't found, returns <code>0</code>. Otherwise, returns the number of <code>key</code>.</li> <li>If <code>*this</code> is empty or <code>key</code> isn't found, returns <code>false</code>. Otherwise, returns <code>true</code>.</li> </ol>"},{"location":"reference/btree_multiset/#capacity","title":"Capacity","text":"<pre><code>// (1)\nsize_type size() const;\n// (2)\nsize_type max_size() const;\n// (3)\nbool      empty() const;\n</code></pre> <ol> <li>Returns the number of values.</li> <li>Returns the max number of values.</li> <li>Returns a bool whether <code>*this</code> is empty or not.</li> </ol>"},{"location":"reference/btree_multiset/#observers","title":"Observers","text":"<pre><code>key_compare key_comp() const noexcept;\n</code></pre> <p>Returns the <code>key_compare</code> object used by <code>*this</code>.</p>"},{"location":"reference/btree_multiset/#non-stl","title":"non-STL","text":"<p>[WARNING] The following functions may be suddenly deleted.</p> <pre><code>// (1)\nsize_type height() const;\n// (2)\nsize_type internal_nodes() const;\n// (3)\nsize_type leaf_nodes() const;\n// (4)\nsize_type nodes() const;\n// (5)\nsize_type bytes_used() const;\n// (6)\ndouble    average_bytes_per_value() const;\n// (7)\ndouble    fullness() const;\n// (8)\ndouble    overhead() const;\n// (9)\nvoid      dump(std::ostream&amp; os) const;\n// (10)\nvoid      verify() const;\n// (11)\nstatic constexpr std::size_t sizeof_leaf_node();\n// (12)\nstatic constexpr std::size_t sizeof_internal_node();\n</code></pre> <ol> <li>Returns the hight of <code>*this</code>.</li> <li>Returns the number of internal nodes.</li> <li>Returns the number of leaf nodes.</li> <li>Returns the total of internal nodes and leaf nodes.</li> <li>Returns the total of bytes used by <code>*this</code>.</li> <li>Returns the average bytes per value.</li> <li>Returns the fullness of <code>*this</code>, which is computed as the number of elements in <code>*this</code> divided by the maximum number of elements a tree with the current number of nodes could hold. A value of 1 indicates perfect space utilization. Smaller values indicate space wastage.</li> <li>Returns the overhead of the btree structure in bytes per node, which is computed as the total number of bytes used by <code>*this</code> minus the number of bytes used for storing elements divided by the number of values.</li> <li>Dumps the btree to the specified ostream. Requires that <code>operator&lt;&lt;</code> is defined for value.</li> <li>Verifies the structure of <code>*this</code>.</li> <li>Returns the size of a leaf node.</li> <li>Returns the size of a internal node.</li> </ol>"},{"location":"reference/btree_multiset/#non-member-function","title":"Non-member function","text":""},{"location":"reference/btree_multiset/#swap","title":"Swap","text":"<pre><code>template &lt;typename K, typename C, typename A, std::size_t N&gt;\nvoid swap(btree_multiset&lt;K, C, A, N&gt;&amp; x, btree_multiset&lt;K, C, A, N&gt;&amp; y);\n</code></pre> <p>Swap <code>x</code> for <code>y</code> using <code>std::swap</code> to swap each member variable of <code>x</code> for that of <code>y</code>.</p>"},{"location":"reference/btree_set/","title":"btree_set","text":""},{"location":"reference/btree_set/#btree_set","title":"btree_set","text":"<p>In <code>platanus/btree_set.hpp</code>,</p> <pre><code>namespace platanus {\ntemplate &lt;\n    typename Key,\n    typename Compare           = std::ranges::less,\n    typename Alloc             = std::allocator&lt;Key&gt;,\n    std::size_t MaxNumOfValues = 512&gt;\nclass btree_set;\n}\n</code></pre>"},{"location":"reference/btree_set/#template-parameters","title":"Template parameters","text":"Parameter Meaning <code>Key</code> Type of a key <code>Compare</code> Type of a func obj comparing two key in a weak order. If Key doesn't implement three-way comparison operator, the default type does using <code>&lt;</code> and <code>=</code>. <code>Alloc</code> Type of an allocator. The default is <code>std::allocator&lt;Key&gt;</code>. <code>MaxNumOfValues</code> The max number of values per node. The default is 64."},{"location":"reference/btree_set/#member-types","title":"Member types","text":"Type Meaning key_type Type of key, i.e. <code>Key</code> value_type Type of value, i.e. <code>Key</code> key_compare Type of comparer of key, i.e. <code>Compare</code> value_compare Type of comparer of value, i.e. <code>Compare</code> allocator_type Type of allocator, i.e. <code>Alloc</code> pointer Type of pointer to value, i.e. <code>Key*</code> const_pointer Type of pointer to const value, i.e. <code>const Key*</code> reference Type of reference to value, i.e. <code>Key&amp;</code> const_reference Type of reference to const value, i.e. <code>const Key&amp;</code> size_type Unsigned integer type of size of <code>btree_set</code>, i.e. <code>std::size_t</code> difference_type Signed integer type of the difference of two iterators iterator Type of iterator const_iterator Type of const iterator reverse_iterator Type of reverse iterator const_reverse_iterator Type of const reverse iterator"},{"location":"reference/btree_set/#member-function","title":"Member function","text":""},{"location":"reference/btree_set/#constructor","title":"Constructor","text":"<pre><code>// (1)\nbtree_set();\n// (2)\nbtree_set(const btree_set&amp;);\n// (3)\nbtree_set(btree_set&amp;&amp;);\n\n// (4)\nexplicit btree_set(const key_compare&amp; comp, const allocator_type&amp; alloc = allocator_type());\n// (5)\nexplicit btree_set(const allocator_type&amp; alloc);\n\n// (6)\ntemplate &lt;class InputIterator&gt;\nbtree_set(\n    InputIterator         b,\n    InputIterator         e,\n    const key_compare&amp;    comp  = key_compare(),\n    const allocator_type&amp; alloc = allocator_type()\n);\n// (7)\ntemplate &lt;class InputIterator&gt;\nbtree_set(InputIterator b, InputIterator e, const allocator_type&amp; alloc);\n\n// (8)\nbtree_set(const btree_set&amp; x, const allocator_type&amp; alloc);\n// (9)\nbtree_set(btree_set&amp;&amp; x, const allocator_type&amp; alloc);\n\n// (10)\nbtree_set(\n    std::initializer_list&lt;value_type&gt; init,\n    const key_compare&amp;                comp  = key_compare{},\n    const allocator_type&amp;             alloc = allocator_type{}\n);\n// (11)\nbtree_set(std::initializer_list&lt;value_type&gt; init, const allocator_type&amp; alloc);\n\n// (12)\nbtree_set&amp; operator=(const btree_set&amp; x);\n// (13)\nbtree_set&amp; operator=(btree_set&amp;&amp;) = default;\n</code></pre> <ol> <li>Constructs an empty <code>btree_set</code>.</li> <li>Copy constructor. The allocator is copied by <code>std::allocator_traits::select_on_container_copy_construction</code>.</li> <li>Move constructor. The allocator is copied by <code>operator=</code>.</li> <li>Constructs an empty <code>btree_set</code> with <code>comp</code> and <code>alloc</code>.</li> <li>Constructs an empty <code>btree_set</code> with <code>alloc</code>.</li> <li>Constructs a <code>btree_set</code> with <code>comp</code> and <code>alloc</code> by inserting values from <code>b</code> to <code>e</code> (<code>e</code> isn't included).</li> <li>Constructs a <code>btree_set</code> with <code>alloc</code> by inserting values from <code>b</code> to <code>e</code> (<code>e</code> isn't included).</li> <li>Constructs a copy of <code>x</code> with <code>alloc</code>.</li> <li>Constructs a <code>btree_set</code> to which <code>x</code> is moved with <code>alloc</code>.</li> <li>Constructs a <code>btree_set</code> with <code>comp</code> and <code>alloc</code> from an initializer list.</li> <li>Constructs a <code>btree_set</code> with <code>alloc</code> from an initializer list.</li> <li>Assigns a copy of <code>x</code> and return <code>*this</code>. If <code>x</code> is <code>*this</code>, does nothing.</li> <li>Default move assignment operator.</li> </ol>"},{"location":"reference/btree_set/#iterator","title":"Iterator","text":"<pre><code>// (1)\niterator               begin();\n// (2)\nconst_iterator         begin() const;\n// (3)\nconst_iterator         cbegin() const;\n\n// (4)\niterator               end();\n// (5)\nconst_iterator         end() const;\n// (6)\nconst_iterator         cend() const;\n\n// (7)\nreverse_iterator       rbegin();\n// (8)\nconst_reverse_iterator rbegin() const;\n// (9)\nconst_reverse_iterator crbegin() const;\n\n// (10)\nreverse_iterator       rend();\n// (11)\nconst_reverse_iterator rend() const;\n// (12)\nconst_reverse_iterator crend() const;\n</code></pre> <ol> <li>Return the iterator pointing to the first value of <code>*this</code>.</li> <li>The <code>const</code> version of 1.</li> <li>Return the const iterator pointing to the first value of <code>*this</code>.</li> <li>Return the iterator pointing to the next address of the last value of <code>*this</code>.</li> <li>The <code>const</code> version of 4.</li> <li>Return the const iterator pointing to the next address of the last value of <code>*this</code>.</li> <li>Return the reverse iterator pointing to the last value of <code>*this</code>.</li> <li>The <code>const</code> version of 7.</li> <li>Return the const reverse iterator pointing to the last value of <code>*this</code>.</li> <li>Return the reverse iterator pointing to the previous address of the first value of <code>*this</code>.</li> <li>The <code>const</code> version of 10.</li> <li>Return the const reverse iterator pointing to the previous address of the first value of <code>*this</code>.</li> </ol>"},{"location":"reference/btree_set/#modifiers","title":"Modifiers","text":"<pre><code>// (1)\nvoid clear();\n// (2)\nvoid swap(btree_set&amp; x);\n// (3)\nvoid merge(btree_set&amp; x);\n// (4)\nvoid merge(btree_set&amp;&amp; x);\n</code></pre> <ol> <li>Clear <code>*this</code>, i.e., delete all values in <code>*this</code>.</li> <li>Swap <code>*this</code> for <code>x</code>.</li> <li>Merge another <code>btree_set</code>. The duplicated values will not be merged to <code>*this</code>.</li> <li>Same as 3. This function is provided to receive an rvalue <code>btree_set</code>, so no rvalue-specific optimization is done.</li> </ol>"},{"location":"reference/btree_set/#insert","title":"<code>insert</code>","text":"<pre><code>// (1)\nstd::pair&lt;iterator, bool&gt; insert(const value_type&amp; x);\n// (2)\nstd::pair&lt;iterator, bool&gt; insert(value_type&amp;&amp; x);\n\n// (3)\niterator insert(iterator hint, const value_type&amp; x);\n// (4)\niterator insert(iterator hint, value_type&amp;&amp; x);\n\n// (5)\ntemplate &lt;typename InputIterator&gt;\nvoid insert(InputIterator b, InputIterator e);\n\n// (6)\nvoid insert(std::initializer_list&lt;value_type&gt; list);\n</code></pre> <ol> <li>If there is <code>x</code> in <code>*this</code>, returns an iterator pointing to <code>x</code> in <code>*this</code> and <code>false</code>. Otherwise, inserts <code>x</code> and returns an iterator pointing to <code>x</code> in <code>*this</code> and <code>true</code>.</li> <li>The rvalue version of 1.</li> <li>Does 1 with hint. If the value is placed immediately before <code>hint</code> in the tree, the insertion will take amortized constant time. If not, the insertion will take amortized logarithmic time as if a call to <code>insert(x)</code> were made.</li> <li>The rvalue version of 3.</li> <li>Does 1 for each value from <code>b</code> to <code>e</code> (<code>e</code> isn't included).</li> <li>Does 1 for each value of <code>list</code>.</li> </ol>"},{"location":"reference/btree_set/#erase","title":"<code>erase</code>","text":"<pre><code>size_type erase(const key_type&amp; key);\niterator  erase(const iterator&amp; iter);\nvoid      erase(const iterator&amp; b, const iterator&amp; e);\n</code></pre> <ol> <li>Erases the specified key from <code>*this</code> and returns</li> <li>Erases the specified iterator from <code>*this</code>. The iterator must be valid (i.e. not equal to end()). Return an iterator pointing to the node after the one that was erased (or end() if none exists).</li> <li>Erases a range from <code>b</code> to <code>e</code> (<code>e</code> isn't included) and return the number of erased keys.</li> </ol>"},{"location":"reference/btree_set/#lookup","title":"Lookup","text":"<pre><code>// (1)\niterator       lower_bound(const key_type&amp; key);\n// (2)\nconst_iterator lower_bound(const key_type&amp; key) const;\n\n// (3)\niterator       upper_bound(const key_type&amp; key);\n// (4)\nconst_iterator upper_bound(const key_type&amp; key) const;\n\n// (5)\nstd::pair&lt;iterator, iterator&gt; equal_range(const key_type&amp; key);\n// (6)\nstd::pair&lt;const_iterator, const_iterator&gt; equal_range(const key_type&amp; key) const;\n\n// (7)\niterator       find(const key_type&amp; key);\n// (8)\nconst_iterator find(const key_type&amp; key) const;\n\n// (9)\nsize_type      count(const key_type&amp; key) const;\n\n// (10)\nbool           contains(const key_type&amp; key) const;\n</code></pre> <ol> <li>If <code>*this</code> is empty or <code>key</code> isn't found, returns <code>end()</code>. Otherwise, returns an iterator which points to the minimum value in all values which are not less than <code>key</code>.</li> <li>The <code>const</code> version of 1.</li> <li>If <code>*this</code> is empty or <code>key</code> isn't found, returns <code>end()</code>. Otherwise, returns an iterator which points to the minimum value in all values which are greater than <code>key</code>.</li> <li>The <code>const</code> version of 3.</li> <li>If <code>*this</code> is empty or <code>key</code> isn't found, returns <code>end()</code>. Otherwise, returns a pair of the iterators which point to the fist value in all values which are equal to <code>key</code> and the value next to the last value in them in order.</li> <li>The <code>const</code> version of 5.</li> <li>If <code>*this</code> is empty or <code>key</code> isn't found, returns <code>end()</code>. Otherwise, returns an iterator which points to the fist value in all values which are equal to <code>key</code>.</li> <li>The <code>const</code> version of 7.</li> <li>If <code>*this</code> is empty or <code>key</code> isn't found, returns <code>0</code>. Otherwise, returns <code>1</code>.</li> <li>If <code>*this</code> is empty or <code>key</code> isn't found, returns <code>false</code>. Otherwise, returns <code>true</code>.</li> </ol>"},{"location":"reference/btree_set/#capacity","title":"Capacity","text":"<pre><code>// (1)\nsize_type size() const;\n// (2)\nsize_type max_size() const;\n// (3)\nbool      empty() const;\n</code></pre> <ol> <li>Returns the number of values.</li> <li>Returns the max number of values.</li> <li>Returns a bool whether <code>*this</code> is empty or not.</li> </ol>"},{"location":"reference/btree_set/#observers","title":"Observers","text":"<pre><code>key_compare key_comp() const noexcept;\n</code></pre> <p>Returns the <code>key_compare</code> object used by <code>*this</code>.</p>"},{"location":"reference/btree_set/#non-stl","title":"non-STL","text":"<p>[WARNING] The following functions may be suddenly deleted.</p> <pre><code>// (1)\nsize_type height() const;\n// (2)\nsize_type internal_nodes() const;\n// (3)\nsize_type leaf_nodes() const;\n// (4)\nsize_type nodes() const;\n// (5)\nsize_type bytes_used() const;\n// (6)\ndouble    average_bytes_per_value() const;\n// (7)\ndouble    fullness() const;\n// (8)\ndouble    overhead() const;\n// (9)\nvoid      dump(std::ostream&amp; os) const;\n// (10)\nvoid      verify() const;\n// (11)\nstatic constexpr std::size_t sizeof_leaf_node();\n// (12)\nstatic constexpr std::size_t sizeof_internal_node();\n</code></pre> <ol> <li>Returns the hight of <code>*this</code>.</li> <li>Returns the number of internal nodes.</li> <li>Returns the number of leaf nodes.</li> <li>Returns the total of internal nodes and leaf nodes.</li> <li>Returns the total of bytes used by <code>*this</code>.</li> <li>Returns the average bytes per value.</li> <li>Returns the fullness of <code>*this</code>, which is computed as the number of elements in <code>*this</code> divided by the maximum number of elements a tree with the current number of nodes could hold. A value of 1 indicates perfect space utilization. Smaller values indicate space wastage.</li> <li>Returns the overhead of the btree structure in bytes per node, which is computed as the total number of bytes used by <code>*this</code> minus the number of bytes used for storing elements divided by the number of values.</li> <li>Dumps the btree to the specified ostream. Requires that <code>operator&lt;&lt;</code> is defined for value.</li> <li>Verifies the structure of <code>*this</code>.</li> <li>Returns the size of a leaf node.</li> <li>Returns the size of a internal node.</li> </ol>"},{"location":"reference/btree_set/#non-member-function","title":"Non-member function","text":""},{"location":"reference/btree_set/#swap","title":"Swap","text":"<pre><code>template &lt;typename K, typename C, typename A, std::size_t N&gt;\nvoid swap(btree_set&lt;K, C, A, N&gt;&amp; x, btree_set&lt;K, C, A, N&gt;&amp; y);\n</code></pre> <p>Swap <code>x</code> for <code>y</code> using <code>std::swap</code> to swap each member variable of <code>x</code> for that of <code>y</code>.</p>"}]}